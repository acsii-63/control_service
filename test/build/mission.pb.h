// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mission.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mission_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_mission_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif // PROTOBUF_VERSION

#if 4023000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h" // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_mission_2eproto

namespace google
{
  namespace protobuf
  {
    namespace internal
    {
      class AnyMetadata;
    } // namespace internal
  }   // namespace protobuf
} // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_mission_2eproto
{
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_mission_2eproto;
namespace mission
{
  namespace v1
  {
    class ActionInstruction;
    struct ActionInstructionDefaultTypeInternal;
    extern ActionInstructionDefaultTypeInternal _ActionInstruction_default_instance_;
    class InitInstruction;
    struct InitInstructionDefaultTypeInternal;
    extern InitInstructionDefaultTypeInternal _InitInstruction_default_instance_;
    class SendMissionRequest;
    struct SendMissionRequestDefaultTypeInternal;
    extern SendMissionRequestDefaultTypeInternal _SendMissionRequest_default_instance_;
    class SendMissionResult;
    struct SendMissionResultDefaultTypeInternal;
    extern SendMissionResultDefaultTypeInternal _SendMissionResult_default_instance_;
    class SequenceItem;
    struct SequenceItemDefaultTypeInternal;
    extern SequenceItemDefaultTypeInternal _SequenceItem_default_instance_;
    class SingleInstruction;
    struct SingleInstructionDefaultTypeInternal;
    extern SingleInstructionDefaultTypeInternal _SingleInstruction_default_instance_;
    class TravelInstruction;
    struct TravelInstructionDefaultTypeInternal;
    extern TravelInstructionDefaultTypeInternal _TravelInstruction_default_instance_;
  } // namespace v1
} // namespace mission
namespace google
{
  namespace protobuf
  {
    template <>
    ::mission::v1::ActionInstruction *Arena::CreateMaybeMessage<::mission::v1::ActionInstruction>(Arena *);
    template <>
    ::mission::v1::InitInstruction *Arena::CreateMaybeMessage<::mission::v1::InitInstruction>(Arena *);
    template <>
    ::mission::v1::SendMissionRequest *Arena::CreateMaybeMessage<::mission::v1::SendMissionRequest>(Arena *);
    template <>
    ::mission::v1::SendMissionResult *Arena::CreateMaybeMessage<::mission::v1::SendMissionResult>(Arena *);
    template <>
    ::mission::v1::SequenceItem *Arena::CreateMaybeMessage<::mission::v1::SequenceItem>(Arena *);
    template <>
    ::mission::v1::SingleInstruction *Arena::CreateMaybeMessage<::mission::v1::SingleInstruction>(Arena *);
    template <>
    ::mission::v1::TravelInstruction *Arena::CreateMaybeMessage<::mission::v1::TravelInstruction>(Arena *);
  } // namespace protobuf
} // namespace google

namespace mission
{
  namespace v1
  {
    enum Termination : int
    {
      TERMINATION_AUTO = 0,
      TERMINATION_STD = 1,
      Termination_INT_MIN_SENTINEL_DO_NOT_USE_ =
          std::numeric_limits<::int32_t>::min(),
      Termination_INT_MAX_SENTINEL_DO_NOT_USE_ =
          std::numeric_limits<::int32_t>::max(),
    };

    bool Termination_IsValid(int value);
    constexpr Termination Termination_MIN = static_cast<Termination>(0);
    constexpr Termination Termination_MAX = static_cast<Termination>(1);
    constexpr int Termination_ARRAYSIZE = 1 + 1;
    const ::google::protobuf::EnumDescriptor *
    Termination_descriptor();
    template <typename T>
    const std::string &Termination_Name(T value)
    {
      static_assert(std::is_same<T, Termination>::value ||
                        std::is_integral<T>::value,
                    "Incorrect type passed to Termination_Name().");
      return Termination_Name(static_cast<Termination>(value));
    }
    template <>
    inline const std::string &Termination_Name(Termination value)
    {
      return ::google::protobuf::internal::NameOfDenseEnum<Termination_descriptor,
                                                           0, 1>(
          static_cast<int>(value));
    }
    inline bool Termination_Parse(absl::string_view name, Termination *value)
    {
      return ::google::protobuf::internal::ParseNamedEnum<Termination>(
          Termination_descriptor(), name, value);
    }
    enum Action : int
    {
      ACTION_TAKEOFF = 0,
      ACTION_DISARM = 1,
      ACTION_SELFCHECK = 2,
      ACTION_RELEASE = 3,
      ACTION_RTLHOME = 4,
      ACTION_HOLD = 5,
      ACTION_AUTOLAND = 6,
      Action_INT_MIN_SENTINEL_DO_NOT_USE_ =
          std::numeric_limits<::int32_t>::min(),
      Action_INT_MAX_SENTINEL_DO_NOT_USE_ =
          std::numeric_limits<::int32_t>::max(),
    };

    bool Action_IsValid(int value);
    constexpr Action Action_MIN = static_cast<Action>(0);
    constexpr Action Action_MAX = static_cast<Action>(6);
    constexpr int Action_ARRAYSIZE = 6 + 1;
    const ::google::protobuf::EnumDescriptor *
    Action_descriptor();
    template <typename T>
    const std::string &Action_Name(T value)
    {
      static_assert(std::is_same<T, Action>::value ||
                        std::is_integral<T>::value,
                    "Incorrect type passed to Action_Name().");
      return Action_Name(static_cast<Action>(value));
    }
    template <>
    inline const std::string &Action_Name(Action value)
    {
      return ::google::protobuf::internal::NameOfDenseEnum<Action_descriptor,
                                                           0, 6>(
          static_cast<int>(value));
    }
    inline bool Action_Parse(absl::string_view name, Action *value)
    {
      return ::google::protobuf::internal::ParseNamedEnum<Action>(
          Action_descriptor(), name, value);
    }
    enum Planner : int
    {
      PLANNER_EGO = 0,
      PLANNER_FAST = 1,
      PLANNER_MARKER = 3,
      PLANNER_SAFELAND = 4,
      Planner_INT_MIN_SENTINEL_DO_NOT_USE_ =
          std::numeric_limits<::int32_t>::min(),
      Planner_INT_MAX_SENTINEL_DO_NOT_USE_ =
          std::numeric_limits<::int32_t>::max(),
    };

    bool Planner_IsValid(int value);
    constexpr Planner Planner_MIN = static_cast<Planner>(0);
    constexpr Planner Planner_MAX = static_cast<Planner>(4);
    constexpr int Planner_ARRAYSIZE = 4 + 1;
    const ::google::protobuf::EnumDescriptor *
    Planner_descriptor();
    template <typename T>
    const std::string &Planner_Name(T value)
    {
      static_assert(std::is_same<T, Planner>::value ||
                        std::is_integral<T>::value,
                    "Incorrect type passed to Planner_Name().");
      return Planner_Name(static_cast<Planner>(value));
    }
    template <>
    inline const std::string &Planner_Name(Planner value)
    {
      return ::google::protobuf::internal::NameOfDenseEnum<Planner_descriptor,
                                                           0, 4>(
          static_cast<int>(value));
    }
    inline bool Planner_Parse(absl::string_view name, Planner *value)
    {
      return ::google::protobuf::internal::ParseNamedEnum<Planner>(
          Planner_descriptor(), name, value);
    }
    enum Controller : int
    {
      CONTROLLER_PX4_VELO_FB = 0,
      CONTROLLER_A_FB = 1,
      CONTROLLER_A_FW = 2,
      CONTROLLER_A_ADRJ = 3,
      Controller_INT_MIN_SENTINEL_DO_NOT_USE_ =
          std::numeric_limits<::int32_t>::min(),
      Controller_INT_MAX_SENTINEL_DO_NOT_USE_ =
          std::numeric_limits<::int32_t>::max(),
    };

    bool Controller_IsValid(int value);
    constexpr Controller Controller_MIN = static_cast<Controller>(0);
    constexpr Controller Controller_MAX = static_cast<Controller>(3);
    constexpr int Controller_ARRAYSIZE = 3 + 1;
    const ::google::protobuf::EnumDescriptor *
    Controller_descriptor();
    template <typename T>
    const std::string &Controller_Name(T value)
    {
      static_assert(std::is_same<T, Controller>::value ||
                        std::is_integral<T>::value,
                    "Incorrect type passed to Controller_Name().");
      return Controller_Name(static_cast<Controller>(value));
    }
    template <>
    inline const std::string &Controller_Name(Controller value)
    {
      return ::google::protobuf::internal::NameOfDenseEnum<Controller_descriptor,
                                                           0, 3>(
          static_cast<int>(value));
    }
    inline bool Controller_Parse(absl::string_view name, Controller *value)
    {
      return ::google::protobuf::internal::ParseNamedEnum<Controller>(
          Controller_descriptor(), name, value);
    }

    // ===================================================================

    // -------------------------------------------------------------------

    class InitInstruction final : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mission.v1.InitInstruction) */
    {
    public:
      inline InitInstruction() : InitInstruction(nullptr) {}
      ~InitInstruction() override;
      explicit PROTOBUF_CONSTEXPR InitInstruction(::google::protobuf::internal::ConstantInitialized);

      InitInstruction(const InitInstruction &from);
      InitInstruction(InitInstruction &&from) noexcept
          : InitInstruction()
      {
        *this = ::std::move(from);
      }

      inline InitInstruction &operator=(const InitInstruction &from)
      {
        CopyFrom(from);
        return *this;
      }
      inline InitInstruction &operator=(InitInstruction &&from) noexcept
      {
        if (this == &from)
          return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
          InternalSwap(&from);
        }
        else
        {
          CopyFrom(from);
        }
        return *this;
      }

      inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const
      {
        return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
      }
      inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields()
      {
        return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
      }

      static const ::google::protobuf::Descriptor *descriptor()
      {
        return GetDescriptor();
      }
      static const ::google::protobuf::Descriptor *GetDescriptor()
      {
        return default_instance().GetMetadata().descriptor;
      }
      static const ::google::protobuf::Reflection *GetReflection()
      {
        return default_instance().GetMetadata().reflection;
      }
      static const InitInstruction &default_instance()
      {
        return *internal_default_instance();
      }
      static inline const InitInstruction *internal_default_instance()
      {
        return reinterpret_cast<const InitInstruction *>(
            &_InitInstruction_default_instance_);
      }
      static constexpr int kIndexInFileMessages =
          0;

      friend void swap(InitInstruction &a, InitInstruction &b)
      {
        a.Swap(&b);
      }
      inline void Swap(InitInstruction *other)
      {
        if (other == this)
          return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr &&
            GetOwningArena() == other->GetOwningArena())
        {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena())
        {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
          InternalSwap(other);
        }
        else
        {
          ::google::protobuf::internal::GenericSwap(this, other);
        }
      }
      void UnsafeArenaSwap(InitInstruction *other)
      {
        if (other == this)
          return;
        ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
      }

      // implements Message ----------------------------------------------

      InitInstruction *New(::google::protobuf::Arena *arena = nullptr) const final
      {
        return CreateMaybeMessage<InitInstruction>(arena);
      }
      using ::google::protobuf::Message::CopyFrom;
      void CopyFrom(const InitInstruction &from);
      using ::google::protobuf::Message::MergeFrom;
      void MergeFrom(const InitInstruction &from)
      {
        InitInstruction::MergeImpl(*this, from);
      }

    private:
      static void MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg);

    public:
      PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
      bool IsInitialized() const final;

      ::size_t ByteSizeLong() const final;
      const char *_InternalParse(const char *ptr, ::google::protobuf::internal::ParseContext *ctx) final;
      ::uint8_t *_InternalSerialize(
          ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const final;
      int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
      void SharedCtor(::google::protobuf::Arena *arena);
      void SharedDtor();
      void SetCachedSize(int size) const final;
      void InternalSwap(InitInstruction *other);

    private:
      friend class ::google::protobuf::internal::AnyMetadata;
      static ::absl::string_view FullMessageName()
      {
        return "mission.v1.InitInstruction";
      }

    protected:
      explicit InitInstruction(::google::protobuf::Arena *arena);

    public:
      static const ClassData _class_data_;
      const ::google::protobuf::Message::ClassData *GetClassData() const final;

      ::google::protobuf::Metadata GetMetadata() const final;

      // nested types ----------------------------------------------------

      // accessors -------------------------------------------------------

      enum : int
      {
        kPeripheralFieldNumber = 1,
        kControllerFieldNumber = 2,
        kTerminateFieldNumber = 3,
      };
      // repeated int32 peripheral = 1;
      int peripheral_size() const;

    private:
      int _internal_peripheral_size() const;

    public:
      void clear_peripheral();
      ::int32_t peripheral(int index) const;
      void set_peripheral(int index, ::int32_t value);
      void add_peripheral(::int32_t value);
      const ::google::protobuf::RepeatedField<::int32_t> &peripheral() const;
      ::google::protobuf::RepeatedField<::int32_t> *mutable_peripheral();

    private:
      const ::google::protobuf::RepeatedField<::int32_t> &_internal_peripheral() const;
      ::google::protobuf::RepeatedField<::int32_t> *_internal_mutable_peripheral();

    public:
      // .mission.v1.Controller controller = 2;
      void clear_controller();
      ::mission::v1::Controller controller() const;
      void set_controller(::mission::v1::Controller value);

    private:
      ::mission::v1::Controller _internal_controller() const;
      void _internal_set_controller(::mission::v1::Controller value);

    public:
      // .mission.v1.Termination terminate = 3;
      void clear_terminate();
      ::mission::v1::Termination terminate() const;
      void set_terminate(::mission::v1::Termination value);

    private:
      ::mission::v1::Termination _internal_terminate() const;
      void _internal_set_terminate(::mission::v1::Termination value);

    public:
      // @@protoc_insertion_point(class_scope:mission.v1.InitInstruction)
    private:
      class _Internal;

      template <typename T>
      friend class ::google::protobuf::Arena::InternalHelper;
      typedef void InternalArenaConstructable_;
      typedef void DestructorSkippable_;
      struct Impl_
      {
        ::google::protobuf::RepeatedField<::int32_t> peripheral_;
        mutable ::google::protobuf::internal::CachedSize _peripheral_cached_byte_size_;
        int controller_;
        int terminate_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
      };
      union
      {
        Impl_ _impl_;
      };
      friend struct ::TableStruct_mission_2eproto;
    }; // -------------------------------------------------------------------

    class TravelInstruction final : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mission.v1.TravelInstruction) */
    {
    public:
      inline TravelInstruction() : TravelInstruction(nullptr) {}
      ~TravelInstruction() override;
      explicit PROTOBUF_CONSTEXPR TravelInstruction(::google::protobuf::internal::ConstantInitialized);

      TravelInstruction(const TravelInstruction &from);
      TravelInstruction(TravelInstruction &&from) noexcept
          : TravelInstruction()
      {
        *this = ::std::move(from);
      }

      inline TravelInstruction &operator=(const TravelInstruction &from)
      {
        CopyFrom(from);
        return *this;
      }
      inline TravelInstruction &operator=(TravelInstruction &&from) noexcept
      {
        if (this == &from)
          return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
          InternalSwap(&from);
        }
        else
        {
          CopyFrom(from);
        }
        return *this;
      }

      inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const
      {
        return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
      }
      inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields()
      {
        return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
      }

      static const ::google::protobuf::Descriptor *descriptor()
      {
        return GetDescriptor();
      }
      static const ::google::protobuf::Descriptor *GetDescriptor()
      {
        return default_instance().GetMetadata().descriptor;
      }
      static const ::google::protobuf::Reflection *GetReflection()
      {
        return default_instance().GetMetadata().reflection;
      }
      static const TravelInstruction &default_instance()
      {
        return *internal_default_instance();
      }
      static inline const TravelInstruction *internal_default_instance()
      {
        return reinterpret_cast<const TravelInstruction *>(
            &_TravelInstruction_default_instance_);
      }
      static constexpr int kIndexInFileMessages =
          1;

      friend void swap(TravelInstruction &a, TravelInstruction &b)
      {
        a.Swap(&b);
      }
      inline void Swap(TravelInstruction *other)
      {
        if (other == this)
          return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr &&
            GetOwningArena() == other->GetOwningArena())
        {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena())
        {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
          InternalSwap(other);
        }
        else
        {
          ::google::protobuf::internal::GenericSwap(this, other);
        }
      }
      void UnsafeArenaSwap(TravelInstruction *other)
      {
        if (other == this)
          return;
        ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
      }

      // implements Message ----------------------------------------------

      TravelInstruction *New(::google::protobuf::Arena *arena = nullptr) const final
      {
        return CreateMaybeMessage<TravelInstruction>(arena);
      }
      using ::google::protobuf::Message::CopyFrom;
      void CopyFrom(const TravelInstruction &from);
      using ::google::protobuf::Message::MergeFrom;
      void MergeFrom(const TravelInstruction &from)
      {
        TravelInstruction::MergeImpl(*this, from);
      }

    private:
      static void MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg);

    public:
      PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
      bool IsInitialized() const final;

      ::size_t ByteSizeLong() const final;
      const char *_InternalParse(const char *ptr, ::google::protobuf::internal::ParseContext *ctx) final;
      ::uint8_t *_InternalSerialize(
          ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const final;
      int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
      void SharedCtor(::google::protobuf::Arena *arena);
      void SharedDtor();
      void SetCachedSize(int size) const final;
      void InternalSwap(TravelInstruction *other);

    private:
      friend class ::google::protobuf::internal::AnyMetadata;
      static ::absl::string_view FullMessageName()
      {
        return "mission.v1.TravelInstruction";
      }

    protected:
      explicit TravelInstruction(::google::protobuf::Arena *arena);

    public:
      static const ClassData _class_data_;
      const ::google::protobuf::Message::ClassData *GetClassData() const final;

      ::google::protobuf::Metadata GetMetadata() const final;

      // nested types ----------------------------------------------------

      // accessors -------------------------------------------------------

      enum : int
      {
        kWaypointFieldNumber = 2,
        kConstraintFieldNumber = 3,
        kPlannerFieldNumber = 1,
        kTerminateFieldNumber = 4,
      };
      // repeated double waypoint = 2;
      int waypoint_size() const;

    private:
      int _internal_waypoint_size() const;

    public:
      void clear_waypoint();
      double waypoint(int index) const;
      void set_waypoint(int index, double value);
      void add_waypoint(double value);
      const ::google::protobuf::RepeatedField<double> &waypoint() const;
      ::google::protobuf::RepeatedField<double> *mutable_waypoint();

    private:
      const ::google::protobuf::RepeatedField<double> &_internal_waypoint() const;
      ::google::protobuf::RepeatedField<double> *_internal_mutable_waypoint();

    public:
      // repeated double constraint = 3;
      int constraint_size() const;

    private:
      int _internal_constraint_size() const;

    public:
      void clear_constraint();
      double constraint(int index) const;
      void set_constraint(int index, double value);
      void add_constraint(double value);
      const ::google::protobuf::RepeatedField<double> &constraint() const;
      ::google::protobuf::RepeatedField<double> *mutable_constraint();

    private:
      const ::google::protobuf::RepeatedField<double> &_internal_constraint() const;
      ::google::protobuf::RepeatedField<double> *_internal_mutable_constraint();

    public:
      // .mission.v1.Planner planner = 1;
      void clear_planner();
      ::mission::v1::Planner planner() const;
      void set_planner(::mission::v1::Planner value);

    private:
      ::mission::v1::Planner _internal_planner() const;
      void _internal_set_planner(::mission::v1::Planner value);

    public:
      // .mission.v1.Termination terminate = 4;
      void clear_terminate();
      ::mission::v1::Termination terminate() const;
      void set_terminate(::mission::v1::Termination value);

    private:
      ::mission::v1::Termination _internal_terminate() const;
      void _internal_set_terminate(::mission::v1::Termination value);

    public:
      // @@protoc_insertion_point(class_scope:mission.v1.TravelInstruction)
    private:
      class _Internal;

      template <typename T>
      friend class ::google::protobuf::Arena::InternalHelper;
      typedef void InternalArenaConstructable_;
      typedef void DestructorSkippable_;
      struct Impl_
      {
        ::google::protobuf::RepeatedField<double> waypoint_;
        ::google::protobuf::RepeatedField<double> constraint_;
        int planner_;
        int terminate_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
      };
      union
      {
        Impl_ _impl_;
      };
      friend struct ::TableStruct_mission_2eproto;
    }; // -------------------------------------------------------------------

    class ActionInstruction final : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mission.v1.ActionInstruction) */
    {
    public:
      inline ActionInstruction() : ActionInstruction(nullptr) {}
      ~ActionInstruction() override;
      explicit PROTOBUF_CONSTEXPR ActionInstruction(::google::protobuf::internal::ConstantInitialized);

      ActionInstruction(const ActionInstruction &from);
      ActionInstruction(ActionInstruction &&from) noexcept
          : ActionInstruction()
      {
        *this = ::std::move(from);
      }

      inline ActionInstruction &operator=(const ActionInstruction &from)
      {
        CopyFrom(from);
        return *this;
      }
      inline ActionInstruction &operator=(ActionInstruction &&from) noexcept
      {
        if (this == &from)
          return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
          InternalSwap(&from);
        }
        else
        {
          CopyFrom(from);
        }
        return *this;
      }

      inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const
      {
        return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
      }
      inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields()
      {
        return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
      }

      static const ::google::protobuf::Descriptor *descriptor()
      {
        return GetDescriptor();
      }
      static const ::google::protobuf::Descriptor *GetDescriptor()
      {
        return default_instance().GetMetadata().descriptor;
      }
      static const ::google::protobuf::Reflection *GetReflection()
      {
        return default_instance().GetMetadata().reflection;
      }
      static const ActionInstruction &default_instance()
      {
        return *internal_default_instance();
      }
      static inline const ActionInstruction *internal_default_instance()
      {
        return reinterpret_cast<const ActionInstruction *>(
            &_ActionInstruction_default_instance_);
      }
      static constexpr int kIndexInFileMessages =
          2;

      friend void swap(ActionInstruction &a, ActionInstruction &b)
      {
        a.Swap(&b);
      }
      inline void Swap(ActionInstruction *other)
      {
        if (other == this)
          return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr &&
            GetOwningArena() == other->GetOwningArena())
        {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena())
        {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
          InternalSwap(other);
        }
        else
        {
          ::google::protobuf::internal::GenericSwap(this, other);
        }
      }
      void UnsafeArenaSwap(ActionInstruction *other)
      {
        if (other == this)
          return;
        ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
      }

      // implements Message ----------------------------------------------

      ActionInstruction *New(::google::protobuf::Arena *arena = nullptr) const final
      {
        return CreateMaybeMessage<ActionInstruction>(arena);
      }
      using ::google::protobuf::Message::CopyFrom;
      void CopyFrom(const ActionInstruction &from);
      using ::google::protobuf::Message::MergeFrom;
      void MergeFrom(const ActionInstruction &from)
      {
        ActionInstruction::MergeImpl(*this, from);
      }

    private:
      static void MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg);

    public:
      PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
      bool IsInitialized() const final;

      ::size_t ByteSizeLong() const final;
      const char *_InternalParse(const char *ptr, ::google::protobuf::internal::ParseContext *ctx) final;
      ::uint8_t *_InternalSerialize(
          ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const final;
      int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
      void SharedCtor(::google::protobuf::Arena *arena);
      void SharedDtor();
      void SetCachedSize(int size) const final;
      void InternalSwap(ActionInstruction *other);

    private:
      friend class ::google::protobuf::internal::AnyMetadata;
      static ::absl::string_view FullMessageName()
      {
        return "mission.v1.ActionInstruction";
      }

    protected:
      explicit ActionInstruction(::google::protobuf::Arena *arena);

    public:
      static const ClassData _class_data_;
      const ::google::protobuf::Message::ClassData *GetClassData() const final;

      ::google::protobuf::Metadata GetMetadata() const final;

      // nested types ----------------------------------------------------

      // accessors -------------------------------------------------------

      enum : int
      {
        kPackageFieldNumber = 2,
        kParamFieldNumber = 3,
        kActionFieldNumber = 1,
      };
      // repeated int32 package = 2;
      int package_size() const;

    private:
      int _internal_package_size() const;

    public:
      void clear_package();
      ::int32_t package(int index) const;
      void set_package(int index, ::int32_t value);
      void add_package(::int32_t value);
      const ::google::protobuf::RepeatedField<::int32_t> &package() const;
      ::google::protobuf::RepeatedField<::int32_t> *mutable_package();

    private:
      const ::google::protobuf::RepeatedField<::int32_t> &_internal_package() const;
      ::google::protobuf::RepeatedField<::int32_t> *_internal_mutable_package();

    public:
      // double param = 3;
      void clear_param();
      double param() const;
      void set_param(double value);

    private:
      double _internal_param() const;
      void _internal_set_param(double value);

    public:
      // .mission.v1.Action action = 1;
      void clear_action();
      ::mission::v1::Action action() const;
      void set_action(::mission::v1::Action value);

    private:
      ::mission::v1::Action _internal_action() const;
      void _internal_set_action(::mission::v1::Action value);

    public:
      // @@protoc_insertion_point(class_scope:mission.v1.ActionInstruction)
    private:
      class _Internal;

      template <typename T>
      friend class ::google::protobuf::Arena::InternalHelper;
      typedef void InternalArenaConstructable_;
      typedef void DestructorSkippable_;
      struct Impl_
      {
        ::google::protobuf::RepeatedField<::int32_t> package_;
        mutable ::google::protobuf::internal::CachedSize _package_cached_byte_size_;
        double param_;
        int action_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
      };
      union
      {
        Impl_ _impl_;
      };
      friend struct ::TableStruct_mission_2eproto;
    }; // -------------------------------------------------------------------

    class SequenceItem final : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mission.v1.SequenceItem) */
    {
    public:
      inline SequenceItem() : SequenceItem(nullptr) {}
      ~SequenceItem() override;
      explicit PROTOBUF_CONSTEXPR SequenceItem(::google::protobuf::internal::ConstantInitialized);

      SequenceItem(const SequenceItem &from);
      SequenceItem(SequenceItem &&from) noexcept
          : SequenceItem()
      {
        *this = ::std::move(from);
      }

      inline SequenceItem &operator=(const SequenceItem &from)
      {
        CopyFrom(from);
        return *this;
      }
      inline SequenceItem &operator=(SequenceItem &&from) noexcept
      {
        if (this == &from)
          return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
          InternalSwap(&from);
        }
        else
        {
          CopyFrom(from);
        }
        return *this;
      }

      inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const
      {
        return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
      }
      inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields()
      {
        return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
      }

      static const ::google::protobuf::Descriptor *descriptor()
      {
        return GetDescriptor();
      }
      static const ::google::protobuf::Descriptor *GetDescriptor()
      {
        return default_instance().GetMetadata().descriptor;
      }
      static const ::google::protobuf::Reflection *GetReflection()
      {
        return default_instance().GetMetadata().reflection;
      }
      static const SequenceItem &default_instance()
      {
        return *internal_default_instance();
      }
      enum SequenceCase
      {
        kInitSequence = 1,
        kActionSequence = 2,
        kTravelSequence = 3,
        SEQUENCE_NOT_SET = 0,
      };

      static inline const SequenceItem *internal_default_instance()
      {
        return reinterpret_cast<const SequenceItem *>(
            &_SequenceItem_default_instance_);
      }
      static constexpr int kIndexInFileMessages =
          3;

      friend void swap(SequenceItem &a, SequenceItem &b)
      {
        a.Swap(&b);
      }
      inline void Swap(SequenceItem *other)
      {
        if (other == this)
          return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr &&
            GetOwningArena() == other->GetOwningArena())
        {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena())
        {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
          InternalSwap(other);
        }
        else
        {
          ::google::protobuf::internal::GenericSwap(this, other);
        }
      }
      void UnsafeArenaSwap(SequenceItem *other)
      {
        if (other == this)
          return;
        ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
      }

      // implements Message ----------------------------------------------

      SequenceItem *New(::google::protobuf::Arena *arena = nullptr) const final
      {
        return CreateMaybeMessage<SequenceItem>(arena);
      }
      using ::google::protobuf::Message::CopyFrom;
      void CopyFrom(const SequenceItem &from);
      using ::google::protobuf::Message::MergeFrom;
      void MergeFrom(const SequenceItem &from)
      {
        SequenceItem::MergeImpl(*this, from);
      }

    private:
      static void MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg);

    public:
      PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
      bool IsInitialized() const final;

      ::size_t ByteSizeLong() const final;
      const char *_InternalParse(const char *ptr, ::google::protobuf::internal::ParseContext *ctx) final;
      ::uint8_t *_InternalSerialize(
          ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const final;
      int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
      void SharedCtor(::google::protobuf::Arena *arena);
      void SharedDtor();
      void SetCachedSize(int size) const final;
      void InternalSwap(SequenceItem *other);

    private:
      friend class ::google::protobuf::internal::AnyMetadata;
      static ::absl::string_view FullMessageName()
      {
        return "mission.v1.SequenceItem";
      }

    protected:
      explicit SequenceItem(::google::protobuf::Arena *arena);

    public:
      static const ClassData _class_data_;
      const ::google::protobuf::Message::ClassData *GetClassData() const final;

      ::google::protobuf::Metadata GetMetadata() const final;

      // nested types ----------------------------------------------------

      // accessors -------------------------------------------------------

      enum : int
      {
        kInitSequenceFieldNumber = 1,
        kActionSequenceFieldNumber = 2,
        kTravelSequenceFieldNumber = 3,
      };
      // .mission.v1.InitInstruction init_sequence = 1;
      bool has_init_sequence() const;

    private:
      bool _internal_has_init_sequence() const;

    public:
      void clear_init_sequence();
      const ::mission::v1::InitInstruction &init_sequence() const;
      PROTOBUF_NODISCARD ::mission::v1::InitInstruction *release_init_sequence();
      ::mission::v1::InitInstruction *mutable_init_sequence();
      void set_allocated_init_sequence(::mission::v1::InitInstruction *value);
      void unsafe_arena_set_allocated_init_sequence(::mission::v1::InitInstruction *value);
      ::mission::v1::InitInstruction *unsafe_arena_release_init_sequence();

    private:
      const ::mission::v1::InitInstruction &_internal_init_sequence() const;
      ::mission::v1::InitInstruction *_internal_mutable_init_sequence();

    public:
      // .mission.v1.ActionInstruction action_sequence = 2;
      bool has_action_sequence() const;

    private:
      bool _internal_has_action_sequence() const;

    public:
      void clear_action_sequence();
      const ::mission::v1::ActionInstruction &action_sequence() const;
      PROTOBUF_NODISCARD ::mission::v1::ActionInstruction *release_action_sequence();
      ::mission::v1::ActionInstruction *mutable_action_sequence();
      void set_allocated_action_sequence(::mission::v1::ActionInstruction *value);
      void unsafe_arena_set_allocated_action_sequence(::mission::v1::ActionInstruction *value);
      ::mission::v1::ActionInstruction *unsafe_arena_release_action_sequence();

    private:
      const ::mission::v1::ActionInstruction &_internal_action_sequence() const;
      ::mission::v1::ActionInstruction *_internal_mutable_action_sequence();

    public:
      // .mission.v1.TravelInstruction travel_sequence = 3;
      bool has_travel_sequence() const;

    private:
      bool _internal_has_travel_sequence() const;

    public:
      void clear_travel_sequence();
      const ::mission::v1::TravelInstruction &travel_sequence() const;
      PROTOBUF_NODISCARD ::mission::v1::TravelInstruction *release_travel_sequence();
      ::mission::v1::TravelInstruction *mutable_travel_sequence();
      void set_allocated_travel_sequence(::mission::v1::TravelInstruction *value);
      void unsafe_arena_set_allocated_travel_sequence(::mission::v1::TravelInstruction *value);
      ::mission::v1::TravelInstruction *unsafe_arena_release_travel_sequence();

    private:
      const ::mission::v1::TravelInstruction &_internal_travel_sequence() const;
      ::mission::v1::TravelInstruction *_internal_mutable_travel_sequence();

    public:
      void clear_sequence();
      SequenceCase sequence_case() const;
      // @@protoc_insertion_point(class_scope:mission.v1.SequenceItem)
    private:
      class _Internal;
      void set_has_init_sequence();
      void set_has_action_sequence();
      void set_has_travel_sequence();

      inline bool has_sequence() const;
      inline void clear_has_sequence();

      template <typename T>
      friend class ::google::protobuf::Arena::InternalHelper;
      typedef void InternalArenaConstructable_;
      typedef void DestructorSkippable_;
      struct Impl_
      {
        union SequenceUnion
        {
          constexpr SequenceUnion() : _constinit_{} {}
          ::google::protobuf::internal::ConstantInitialized _constinit_;
          ::mission::v1::InitInstruction *init_sequence_;
          ::mission::v1::ActionInstruction *action_sequence_;
          ::mission::v1::TravelInstruction *travel_sequence_;
        } sequence_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        ::uint32_t _oneof_case_[1];
      };
      union
      {
        Impl_ _impl_;
      };
      friend struct ::TableStruct_mission_2eproto;
    }; // -------------------------------------------------------------------

    class SendMissionRequest final : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mission.v1.SendMissionRequest) */
    {
    public:
      inline SendMissionRequest() : SendMissionRequest(nullptr) {}
      ~SendMissionRequest() override;
      explicit PROTOBUF_CONSTEXPR SendMissionRequest(::google::protobuf::internal::ConstantInitialized);

      SendMissionRequest(const SendMissionRequest &from);
      SendMissionRequest(SendMissionRequest &&from) noexcept
          : SendMissionRequest()
      {
        *this = ::std::move(from);
      }

      inline SendMissionRequest &operator=(const SendMissionRequest &from)
      {
        CopyFrom(from);
        return *this;
      }
      inline SendMissionRequest &operator=(SendMissionRequest &&from) noexcept
      {
        if (this == &from)
          return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
          InternalSwap(&from);
        }
        else
        {
          CopyFrom(from);
        }
        return *this;
      }

      inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const
      {
        return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
      }
      inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields()
      {
        return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
      }

      static const ::google::protobuf::Descriptor *descriptor()
      {
        return GetDescriptor();
      }
      static const ::google::protobuf::Descriptor *GetDescriptor()
      {
        return default_instance().GetMetadata().descriptor;
      }
      static const ::google::protobuf::Reflection *GetReflection()
      {
        return default_instance().GetMetadata().reflection;
      }
      static const SendMissionRequest &default_instance()
      {
        return *internal_default_instance();
      }
      static inline const SendMissionRequest *internal_default_instance()
      {
        return reinterpret_cast<const SendMissionRequest *>(
            &_SendMissionRequest_default_instance_);
      }
      static constexpr int kIndexInFileMessages =
          4;

      friend void swap(SendMissionRequest &a, SendMissionRequest &b)
      {
        a.Swap(&b);
      }
      inline void Swap(SendMissionRequest *other)
      {
        if (other == this)
          return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr &&
            GetOwningArena() == other->GetOwningArena())
        {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena())
        {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
          InternalSwap(other);
        }
        else
        {
          ::google::protobuf::internal::GenericSwap(this, other);
        }
      }
      void UnsafeArenaSwap(SendMissionRequest *other)
      {
        if (other == this)
          return;
        ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
      }

      // implements Message ----------------------------------------------

      SendMissionRequest *New(::google::protobuf::Arena *arena = nullptr) const final
      {
        return CreateMaybeMessage<SendMissionRequest>(arena);
      }
      using ::google::protobuf::Message::CopyFrom;
      void CopyFrom(const SendMissionRequest &from);
      using ::google::protobuf::Message::MergeFrom;
      void MergeFrom(const SendMissionRequest &from)
      {
        SendMissionRequest::MergeImpl(*this, from);
      }

    private:
      static void MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg);

    public:
      PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
      bool IsInitialized() const final;

      ::size_t ByteSizeLong() const final;
      const char *_InternalParse(const char *ptr, ::google::protobuf::internal::ParseContext *ctx) final;
      ::uint8_t *_InternalSerialize(
          ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const final;
      int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
      void SharedCtor(::google::protobuf::Arena *arena);
      void SharedDtor();
      void SetCachedSize(int size) const final;
      void InternalSwap(SendMissionRequest *other);

    private:
      friend class ::google::protobuf::internal::AnyMetadata;
      static ::absl::string_view FullMessageName()
      {
        return "mission.v1.SendMissionRequest";
      }

    protected:
      explicit SendMissionRequest(::google::protobuf::Arena *arena);

    public:
      static const ClassData _class_data_;
      const ::google::protobuf::Message::ClassData *GetClassData() const final;

      ::google::protobuf::Metadata GetMetadata() const final;

      // nested types ----------------------------------------------------

      // accessors -------------------------------------------------------

      enum : int
      {
        kSequenceItemsFieldNumber = 2,
        kIdFieldNumber = 1,
      };
      // repeated .mission.v1.SequenceItem sequence_items = 2;
      int sequence_items_size() const;

    private:
      int _internal_sequence_items_size() const;

    public:
      void clear_sequence_items();
      ::mission::v1::SequenceItem *mutable_sequence_items(int index);
      ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> *
      mutable_sequence_items();

    private:
      const ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> &_internal_sequence_items() const;
      ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> *_internal_mutable_sequence_items();

    public:
      const ::mission::v1::SequenceItem &sequence_items(int index) const;
      ::mission::v1::SequenceItem *add_sequence_items();
      const ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> &
      sequence_items() const;
      // string id = 1;
      void clear_id();
      const std::string &id() const;
      template <typename Arg_ = const std::string &, typename... Args_>
      void set_id(Arg_ &&arg, Args_... args);
      std::string *mutable_id();
      PROTOBUF_NODISCARD std::string *release_id();
      void set_allocated_id(std::string *ptr);

    private:
      const std::string &_internal_id() const;
      inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
          const std::string &value);
      std::string *_internal_mutable_id();

    public:
      // @@protoc_insertion_point(class_scope:mission.v1.SendMissionRequest)
    private:
      class _Internal;

      template <typename T>
      friend class ::google::protobuf::Arena::InternalHelper;
      typedef void InternalArenaConstructable_;
      typedef void DestructorSkippable_;
      struct Impl_
      {
        ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> sequence_items_;
        ::google::protobuf::internal::ArenaStringPtr id_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
      };
      union
      {
        Impl_ _impl_;
      };
      friend struct ::TableStruct_mission_2eproto;
    }; // -------------------------------------------------------------------

    class SingleInstruction final : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mission.v1.SingleInstruction) */
    {
    public:
      inline SingleInstruction() : SingleInstruction(nullptr) {}
      ~SingleInstruction() override;
      explicit PROTOBUF_CONSTEXPR SingleInstruction(::google::protobuf::internal::ConstantInitialized);

      SingleInstruction(const SingleInstruction &from);
      SingleInstruction(SingleInstruction &&from) noexcept
          : SingleInstruction()
      {
        *this = ::std::move(from);
      }

      inline SingleInstruction &operator=(const SingleInstruction &from)
      {
        CopyFrom(from);
        return *this;
      }
      inline SingleInstruction &operator=(SingleInstruction &&from) noexcept
      {
        if (this == &from)
          return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
          InternalSwap(&from);
        }
        else
        {
          CopyFrom(from);
        }
        return *this;
      }

      inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const
      {
        return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
      }
      inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields()
      {
        return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
      }

      static const ::google::protobuf::Descriptor *descriptor()
      {
        return GetDescriptor();
      }
      static const ::google::protobuf::Descriptor *GetDescriptor()
      {
        return default_instance().GetMetadata().descriptor;
      }
      static const ::google::protobuf::Reflection *GetReflection()
      {
        return default_instance().GetMetadata().reflection;
      }
      static const SingleInstruction &default_instance()
      {
        return *internal_default_instance();
      }
      static inline const SingleInstruction *internal_default_instance()
      {
        return reinterpret_cast<const SingleInstruction *>(
            &_SingleInstruction_default_instance_);
      }
      static constexpr int kIndexInFileMessages =
          5;

      friend void swap(SingleInstruction &a, SingleInstruction &b)
      {
        a.Swap(&b);
      }
      inline void Swap(SingleInstruction *other)
      {
        if (other == this)
          return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr &&
            GetOwningArena() == other->GetOwningArena())
        {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena())
        {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
          InternalSwap(other);
        }
        else
        {
          ::google::protobuf::internal::GenericSwap(this, other);
        }
      }
      void UnsafeArenaSwap(SingleInstruction *other)
      {
        if (other == this)
          return;
        ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
      }

      // implements Message ----------------------------------------------

      SingleInstruction *New(::google::protobuf::Arena *arena = nullptr) const final
      {
        return CreateMaybeMessage<SingleInstruction>(arena);
      }
      using ::google::protobuf::Message::CopyFrom;
      void CopyFrom(const SingleInstruction &from);
      using ::google::protobuf::Message::MergeFrom;
      void MergeFrom(const SingleInstruction &from)
      {
        SingleInstruction::MergeImpl(*this, from);
      }

    private:
      static void MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg);

    public:
      PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
      bool IsInitialized() const final;

      ::size_t ByteSizeLong() const final;
      const char *_InternalParse(const char *ptr, ::google::protobuf::internal::ParseContext *ctx) final;
      ::uint8_t *_InternalSerialize(
          ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const final;
      int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
      void SharedCtor(::google::protobuf::Arena *arena);
      void SharedDtor();
      void SetCachedSize(int size) const final;
      void InternalSwap(SingleInstruction *other);

    private:
      friend class ::google::protobuf::internal::AnyMetadata;
      static ::absl::string_view FullMessageName()
      {
        return "mission.v1.SingleInstruction";
      }

    protected:
      explicit SingleInstruction(::google::protobuf::Arena *arena);

    public:
      static const ClassData _class_data_;
      const ::google::protobuf::Message::ClassData *GetClassData() const final;

      ::google::protobuf::Metadata GetMetadata() const final;

      // nested types ----------------------------------------------------

      // accessors -------------------------------------------------------

      enum : int
      {
        kSequenceItemFieldNumber = 1,
      };
      // .mission.v1.SequenceItem sequence_item = 1;
      bool has_sequence_item() const;
      void clear_sequence_item();
      const ::mission::v1::SequenceItem &sequence_item() const;
      PROTOBUF_NODISCARD ::mission::v1::SequenceItem *release_sequence_item();
      ::mission::v1::SequenceItem *mutable_sequence_item();
      void set_allocated_sequence_item(::mission::v1::SequenceItem *value);
      void unsafe_arena_set_allocated_sequence_item(::mission::v1::SequenceItem *value);
      ::mission::v1::SequenceItem *unsafe_arena_release_sequence_item();

    private:
      const ::mission::v1::SequenceItem &_internal_sequence_item() const;
      ::mission::v1::SequenceItem *_internal_mutable_sequence_item();

    public:
      // @@protoc_insertion_point(class_scope:mission.v1.SingleInstruction)
    private:
      class _Internal;

      template <typename T>
      friend class ::google::protobuf::Arena::InternalHelper;
      typedef void InternalArenaConstructable_;
      typedef void DestructorSkippable_;
      struct Impl_
      {
        ::google::protobuf::internal::HasBits<1> _has_bits_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        ::mission::v1::SequenceItem *sequence_item_;
      };
      union
      {
        Impl_ _impl_;
      };
      friend struct ::TableStruct_mission_2eproto;
    }; // -------------------------------------------------------------------

    class SendMissionResult final : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mission.v1.SendMissionResult) */
    {
    public:
      inline SendMissionResult() : SendMissionResult(nullptr) {}
      ~SendMissionResult() override;
      explicit PROTOBUF_CONSTEXPR SendMissionResult(::google::protobuf::internal::ConstantInitialized);

      SendMissionResult(const SendMissionResult &from);
      SendMissionResult(SendMissionResult &&from) noexcept
          : SendMissionResult()
      {
        *this = ::std::move(from);
      }

      inline SendMissionResult &operator=(const SendMissionResult &from)
      {
        CopyFrom(from);
        return *this;
      }
      inline SendMissionResult &operator=(SendMissionResult &&from) noexcept
      {
        if (this == &from)
          return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
          InternalSwap(&from);
        }
        else
        {
          CopyFrom(from);
        }
        return *this;
      }

      inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const
      {
        return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
      }
      inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields()
      {
        return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
      }

      static const ::google::protobuf::Descriptor *descriptor()
      {
        return GetDescriptor();
      }
      static const ::google::protobuf::Descriptor *GetDescriptor()
      {
        return default_instance().GetMetadata().descriptor;
      }
      static const ::google::protobuf::Reflection *GetReflection()
      {
        return default_instance().GetMetadata().reflection;
      }
      static const SendMissionResult &default_instance()
      {
        return *internal_default_instance();
      }
      static inline const SendMissionResult *internal_default_instance()
      {
        return reinterpret_cast<const SendMissionResult *>(
            &_SendMissionResult_default_instance_);
      }
      static constexpr int kIndexInFileMessages =
          6;

      friend void swap(SendMissionResult &a, SendMissionResult &b)
      {
        a.Swap(&b);
      }
      inline void Swap(SendMissionResult *other)
      {
        if (other == this)
          return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr &&
            GetOwningArena() == other->GetOwningArena())
        {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena())
        {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
          InternalSwap(other);
        }
        else
        {
          ::google::protobuf::internal::GenericSwap(this, other);
        }
      }
      void UnsafeArenaSwap(SendMissionResult *other)
      {
        if (other == this)
          return;
        ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
      }

      // implements Message ----------------------------------------------

      SendMissionResult *New(::google::protobuf::Arena *arena = nullptr) const final
      {
        return CreateMaybeMessage<SendMissionResult>(arena);
      }
      using ::google::protobuf::Message::CopyFrom;
      void CopyFrom(const SendMissionResult &from);
      using ::google::protobuf::Message::MergeFrom;
      void MergeFrom(const SendMissionResult &from)
      {
        SendMissionResult::MergeImpl(*this, from);
      }

    private:
      static void MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg);

    public:
      PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
      bool IsInitialized() const final;

      ::size_t ByteSizeLong() const final;
      const char *_InternalParse(const char *ptr, ::google::protobuf::internal::ParseContext *ctx) final;
      ::uint8_t *_InternalSerialize(
          ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const final;
      int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

    private:
      void SharedCtor(::google::protobuf::Arena *arena);
      void SharedDtor();
      void SetCachedSize(int size) const final;
      void InternalSwap(SendMissionResult *other);

    private:
      friend class ::google::protobuf::internal::AnyMetadata;
      static ::absl::string_view FullMessageName()
      {
        return "mission.v1.SendMissionResult";
      }

    protected:
      explicit SendMissionResult(::google::protobuf::Arena *arena);

    public:
      static const ClassData _class_data_;
      const ::google::protobuf::Message::ClassData *GetClassData() const final;

      ::google::protobuf::Metadata GetMetadata() const final;

      // nested types ----------------------------------------------------

      // accessors -------------------------------------------------------

      enum : int
      {
        kMessageFieldNumber = 2,
        kErrorMessageFieldNumber = 3,
        kSuccessFieldNumber = 1,
      };
      // string message = 2;
      void clear_message();
      const std::string &message() const;
      template <typename Arg_ = const std::string &, typename... Args_>
      void set_message(Arg_ &&arg, Args_... args);
      std::string *mutable_message();
      PROTOBUF_NODISCARD std::string *release_message();
      void set_allocated_message(std::string *ptr);

    private:
      const std::string &_internal_message() const;
      inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
          const std::string &value);
      std::string *_internal_mutable_message();

    public:
      // string error_message = 3;
      void clear_error_message();
      const std::string &error_message() const;
      template <typename Arg_ = const std::string &, typename... Args_>
      void set_error_message(Arg_ &&arg, Args_... args);
      std::string *mutable_error_message();
      PROTOBUF_NODISCARD std::string *release_error_message();
      void set_allocated_error_message(std::string *ptr);

    private:
      const std::string &_internal_error_message() const;
      inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
          const std::string &value);
      std::string *_internal_mutable_error_message();

    public:
      // bool success = 1;
      void clear_success();
      bool success() const;
      void set_success(bool value);

    private:
      bool _internal_success() const;
      void _internal_set_success(bool value);

    public:
      // @@protoc_insertion_point(class_scope:mission.v1.SendMissionResult)
    private:
      class _Internal;

      template <typename T>
      friend class ::google::protobuf::Arena::InternalHelper;
      typedef void InternalArenaConstructable_;
      typedef void DestructorSkippable_;
      struct Impl_
      {
        ::google::protobuf::internal::ArenaStringPtr message_;
        ::google::protobuf::internal::ArenaStringPtr error_message_;
        bool success_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
      };
      union
      {
        Impl_ _impl_;
      };
      friend struct ::TableStruct_mission_2eproto;
    };

    // ===================================================================

    // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
    // -------------------------------------------------------------------

    // InitInstruction

    // repeated int32 peripheral = 1;
    inline int InitInstruction::_internal_peripheral_size() const
    {
      return _impl_.peripheral_.size();
    }
    inline int InitInstruction::peripheral_size() const
    {
      return _internal_peripheral_size();
    }
    inline void InitInstruction::clear_peripheral()
    {
      _internal_mutable_peripheral()->Clear();
    }
    inline ::int32_t InitInstruction::peripheral(int index) const
    {
      // @@protoc_insertion_point(field_get:mission.v1.InitInstruction.peripheral)
      return _internal_peripheral().Get(index);
    }
    inline void InitInstruction::set_peripheral(int index, ::int32_t value)
    {
      _internal_mutable_peripheral()->Set(index, value);
      // @@protoc_insertion_point(field_set:mission.v1.InitInstruction.peripheral)
    }
    inline void InitInstruction::add_peripheral(::int32_t value)
    {
      _internal_mutable_peripheral()->Add(value);
      // @@protoc_insertion_point(field_add:mission.v1.InitInstruction.peripheral)
    }
    inline const ::google::protobuf::RepeatedField<::int32_t> &InitInstruction::peripheral() const
    {
      // @@protoc_insertion_point(field_list:mission.v1.InitInstruction.peripheral)
      return _internal_peripheral();
    }
    inline ::google::protobuf::RepeatedField<::int32_t> *InitInstruction::mutable_peripheral()
    {
      // @@protoc_insertion_point(field_mutable_list:mission.v1.InitInstruction.peripheral)
      return _internal_mutable_peripheral();
    }

    inline const ::google::protobuf::RepeatedField<::int32_t> &InitInstruction::_internal_peripheral() const
    {
      return _impl_.peripheral_;
    }
    inline ::google::protobuf::RepeatedField<::int32_t> *InitInstruction::_internal_mutable_peripheral()
    {
      return &_impl_.peripheral_;
    }

    // .mission.v1.Controller controller = 2;
    inline void InitInstruction::clear_controller()
    {
      _impl_.controller_ = 0;
    }
    inline ::mission::v1::Controller InitInstruction::controller() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.InitInstruction.controller)
      return _internal_controller();
    }
    inline void InitInstruction::set_controller(::mission::v1::Controller value)
    {
      _internal_set_controller(value);
      // @@protoc_insertion_point(field_set:mission.v1.InitInstruction.controller)
    }
    inline ::mission::v1::Controller InitInstruction::_internal_controller() const
    {
      return static_cast<::mission::v1::Controller>(_impl_.controller_);
    }
    inline void InitInstruction::_internal_set_controller(::mission::v1::Controller value)
    {
      ;
      _impl_.controller_ = value;
    }

    // .mission.v1.Termination terminate = 3;
    inline void InitInstruction::clear_terminate()
    {
      _impl_.terminate_ = 0;
    }
    inline ::mission::v1::Termination InitInstruction::terminate() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.InitInstruction.terminate)
      return _internal_terminate();
    }
    inline void InitInstruction::set_terminate(::mission::v1::Termination value)
    {
      _internal_set_terminate(value);
      // @@protoc_insertion_point(field_set:mission.v1.InitInstruction.terminate)
    }
    inline ::mission::v1::Termination InitInstruction::_internal_terminate() const
    {
      return static_cast<::mission::v1::Termination>(_impl_.terminate_);
    }
    inline void InitInstruction::_internal_set_terminate(::mission::v1::Termination value)
    {
      ;
      _impl_.terminate_ = value;
    }

    // -------------------------------------------------------------------

    // TravelInstruction

    // .mission.v1.Planner planner = 1;
    inline void TravelInstruction::clear_planner()
    {
      _impl_.planner_ = 0;
    }
    inline ::mission::v1::Planner TravelInstruction::planner() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.TravelInstruction.planner)
      return _internal_planner();
    }
    inline void TravelInstruction::set_planner(::mission::v1::Planner value)
    {
      _internal_set_planner(value);
      // @@protoc_insertion_point(field_set:mission.v1.TravelInstruction.planner)
    }
    inline ::mission::v1::Planner TravelInstruction::_internal_planner() const
    {
      return static_cast<::mission::v1::Planner>(_impl_.planner_);
    }
    inline void TravelInstruction::_internal_set_planner(::mission::v1::Planner value)
    {
      ;
      _impl_.planner_ = value;
    }

    // repeated double waypoint = 2;
    inline int TravelInstruction::_internal_waypoint_size() const
    {
      return _impl_.waypoint_.size();
    }
    inline int TravelInstruction::waypoint_size() const
    {
      return _internal_waypoint_size();
    }
    inline void TravelInstruction::clear_waypoint()
    {
      _internal_mutable_waypoint()->Clear();
    }
    inline double TravelInstruction::waypoint(int index) const
    {
      // @@protoc_insertion_point(field_get:mission.v1.TravelInstruction.waypoint)
      return _internal_waypoint().Get(index);
    }
    inline void TravelInstruction::set_waypoint(int index, double value)
    {
      _internal_mutable_waypoint()->Set(index, value);
      // @@protoc_insertion_point(field_set:mission.v1.TravelInstruction.waypoint)
    }
    inline void TravelInstruction::add_waypoint(double value)
    {
      _internal_mutable_waypoint()->Add(value);
      // @@protoc_insertion_point(field_add:mission.v1.TravelInstruction.waypoint)
    }
    inline const ::google::protobuf::RepeatedField<double> &TravelInstruction::waypoint() const
    {
      // @@protoc_insertion_point(field_list:mission.v1.TravelInstruction.waypoint)
      return _internal_waypoint();
    }
    inline ::google::protobuf::RepeatedField<double> *TravelInstruction::mutable_waypoint()
    {
      // @@protoc_insertion_point(field_mutable_list:mission.v1.TravelInstruction.waypoint)
      return _internal_mutable_waypoint();
    }

    inline const ::google::protobuf::RepeatedField<double> &TravelInstruction::_internal_waypoint() const
    {
      return _impl_.waypoint_;
    }
    inline ::google::protobuf::RepeatedField<double> *TravelInstruction::_internal_mutable_waypoint()
    {
      return &_impl_.waypoint_;
    }

    // repeated double constraint = 3;
    inline int TravelInstruction::_internal_constraint_size() const
    {
      return _impl_.constraint_.size();
    }
    inline int TravelInstruction::constraint_size() const
    {
      return _internal_constraint_size();
    }
    inline void TravelInstruction::clear_constraint()
    {
      _internal_mutable_constraint()->Clear();
    }
    inline double TravelInstruction::constraint(int index) const
    {
      // @@protoc_insertion_point(field_get:mission.v1.TravelInstruction.constraint)
      return _internal_constraint().Get(index);
    }
    inline void TravelInstruction::set_constraint(int index, double value)
    {
      _internal_mutable_constraint()->Set(index, value);
      // @@protoc_insertion_point(field_set:mission.v1.TravelInstruction.constraint)
    }
    inline void TravelInstruction::add_constraint(double value)
    {
      _internal_mutable_constraint()->Add(value);
      // @@protoc_insertion_point(field_add:mission.v1.TravelInstruction.constraint)
    }
    inline const ::google::protobuf::RepeatedField<double> &TravelInstruction::constraint() const
    {
      // @@protoc_insertion_point(field_list:mission.v1.TravelInstruction.constraint)
      return _internal_constraint();
    }
    inline ::google::protobuf::RepeatedField<double> *TravelInstruction::mutable_constraint()
    {
      // @@protoc_insertion_point(field_mutable_list:mission.v1.TravelInstruction.constraint)
      return _internal_mutable_constraint();
    }

    inline const ::google::protobuf::RepeatedField<double> &TravelInstruction::_internal_constraint() const
    {
      return _impl_.constraint_;
    }
    inline ::google::protobuf::RepeatedField<double> *TravelInstruction::_internal_mutable_constraint()
    {
      return &_impl_.constraint_;
    }

    // .mission.v1.Termination terminate = 4;
    inline void TravelInstruction::clear_terminate()
    {
      _impl_.terminate_ = 0;
    }
    inline ::mission::v1::Termination TravelInstruction::terminate() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.TravelInstruction.terminate)
      return _internal_terminate();
    }
    inline void TravelInstruction::set_terminate(::mission::v1::Termination value)
    {
      _internal_set_terminate(value);
      // @@protoc_insertion_point(field_set:mission.v1.TravelInstruction.terminate)
    }
    inline ::mission::v1::Termination TravelInstruction::_internal_terminate() const
    {
      return static_cast<::mission::v1::Termination>(_impl_.terminate_);
    }
    inline void TravelInstruction::_internal_set_terminate(::mission::v1::Termination value)
    {
      ;
      _impl_.terminate_ = value;
    }

    // -------------------------------------------------------------------

    // ActionInstruction

    // .mission.v1.Action action = 1;
    inline void ActionInstruction::clear_action()
    {
      _impl_.action_ = 0;
    }
    inline ::mission::v1::Action ActionInstruction::action() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.ActionInstruction.action)
      return _internal_action();
    }
    inline void ActionInstruction::set_action(::mission::v1::Action value)
    {
      _internal_set_action(value);
      // @@protoc_insertion_point(field_set:mission.v1.ActionInstruction.action)
    }
    inline ::mission::v1::Action ActionInstruction::_internal_action() const
    {
      return static_cast<::mission::v1::Action>(_impl_.action_);
    }
    inline void ActionInstruction::_internal_set_action(::mission::v1::Action value)
    {
      ;
      _impl_.action_ = value;
    }

    // repeated int32 package = 2;
    inline int ActionInstruction::_internal_package_size() const
    {
      return _impl_.package_.size();
    }
    inline int ActionInstruction::package_size() const
    {
      return _internal_package_size();
    }
    inline void ActionInstruction::clear_package()
    {
      _internal_mutable_package()->Clear();
    }
    inline ::int32_t ActionInstruction::package(int index) const
    {
      // @@protoc_insertion_point(field_get:mission.v1.ActionInstruction.package)
      return _internal_package().Get(index);
    }
    inline void ActionInstruction::set_package(int index, ::int32_t value)
    {
      _internal_mutable_package()->Set(index, value);
      // @@protoc_insertion_point(field_set:mission.v1.ActionInstruction.package)
    }
    inline void ActionInstruction::add_package(::int32_t value)
    {
      _internal_mutable_package()->Add(value);
      // @@protoc_insertion_point(field_add:mission.v1.ActionInstruction.package)
    }
    inline const ::google::protobuf::RepeatedField<::int32_t> &ActionInstruction::package() const
    {
      // @@protoc_insertion_point(field_list:mission.v1.ActionInstruction.package)
      return _internal_package();
    }
    inline ::google::protobuf::RepeatedField<::int32_t> *ActionInstruction::mutable_package()
    {
      // @@protoc_insertion_point(field_mutable_list:mission.v1.ActionInstruction.package)
      return _internal_mutable_package();
    }

    inline const ::google::protobuf::RepeatedField<::int32_t> &ActionInstruction::_internal_package() const
    {
      return _impl_.package_;
    }
    inline ::google::protobuf::RepeatedField<::int32_t> *ActionInstruction::_internal_mutable_package()
    {
      return &_impl_.package_;
    }

    // double param = 3;
    inline void ActionInstruction::clear_param()
    {
      _impl_.param_ = 0;
    }
    inline double ActionInstruction::param() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.ActionInstruction.param)
      return _internal_param();
    }
    inline void ActionInstruction::set_param(double value)
    {
      _internal_set_param(value);
      // @@protoc_insertion_point(field_set:mission.v1.ActionInstruction.param)
    }
    inline double ActionInstruction::_internal_param() const
    {
      return _impl_.param_;
    }
    inline void ActionInstruction::_internal_set_param(double value)
    {
      ;
      _impl_.param_ = value;
    }

    // -------------------------------------------------------------------

    // SequenceItem

    // .mission.v1.InitInstruction init_sequence = 1;
    inline bool SequenceItem::has_init_sequence() const
    {
      return sequence_case() == kInitSequence;
    }
    inline bool SequenceItem::_internal_has_init_sequence() const
    {
      return sequence_case() == kInitSequence;
    }
    inline void SequenceItem::set_has_init_sequence()
    {
      _impl_._oneof_case_[0] = kInitSequence;
    }
    inline void SequenceItem::clear_init_sequence()
    {
      if (sequence_case() == kInitSequence)
      {
        if (GetArenaForAllocation() == nullptr)
        {
          delete _impl_.sequence_.init_sequence_;
        }
        clear_has_sequence();
      }
    }
    inline ::mission::v1::InitInstruction *SequenceItem::release_init_sequence()
    {
      // @@protoc_insertion_point(field_release:mission.v1.SequenceItem.init_sequence)
      if (sequence_case() == kInitSequence)
      {
        clear_has_sequence();
        ::mission::v1::InitInstruction *temp = _impl_.sequence_.init_sequence_;
        if (GetArenaForAllocation() != nullptr)
        {
          temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
        }
        _impl_.sequence_.init_sequence_ = nullptr;
        return temp;
      }
      else
      {
        return nullptr;
      }
    }
    inline const ::mission::v1::InitInstruction &SequenceItem::_internal_init_sequence() const
    {
      return sequence_case() == kInitSequence
                 ? *_impl_.sequence_.init_sequence_
                 : reinterpret_cast<::mission::v1::InitInstruction &>(::mission::v1::_InitInstruction_default_instance_);
    }
    inline const ::mission::v1::InitInstruction &SequenceItem::init_sequence() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SequenceItem.init_sequence)
      return _internal_init_sequence();
    }
    inline ::mission::v1::InitInstruction *SequenceItem::unsafe_arena_release_init_sequence()
    {
      // @@protoc_insertion_point(field_unsafe_arena_release:mission.v1.SequenceItem.init_sequence)
      if (sequence_case() == kInitSequence)
      {
        clear_has_sequence();
        ::mission::v1::InitInstruction *temp = _impl_.sequence_.init_sequence_;
        _impl_.sequence_.init_sequence_ = nullptr;
        return temp;
      }
      else
      {
        return nullptr;
      }
    }
    inline void SequenceItem::unsafe_arena_set_allocated_init_sequence(::mission::v1::InitInstruction *init_sequence)
    {
      clear_sequence();
      if (init_sequence)
      {
        set_has_init_sequence();
        _impl_.sequence_.init_sequence_ = init_sequence;
      }
      // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mission.v1.SequenceItem.init_sequence)
    }
    inline ::mission::v1::InitInstruction *SequenceItem::_internal_mutable_init_sequence()
    {
      if (sequence_case() != kInitSequence)
      {
        clear_sequence();
        set_has_init_sequence();
        _impl_.sequence_.init_sequence_ = CreateMaybeMessage<::mission::v1::InitInstruction>(GetArenaForAllocation());
      }
      return _impl_.sequence_.init_sequence_;
    }
    inline ::mission::v1::InitInstruction *SequenceItem::mutable_init_sequence()
    {
      ::mission::v1::InitInstruction *_msg = _internal_mutable_init_sequence();
      // @@protoc_insertion_point(field_mutable:mission.v1.SequenceItem.init_sequence)
      return _msg;
    }

    // .mission.v1.ActionInstruction action_sequence = 2;
    inline bool SequenceItem::has_action_sequence() const
    {
      return sequence_case() == kActionSequence;
    }
    inline bool SequenceItem::_internal_has_action_sequence() const
    {
      return sequence_case() == kActionSequence;
    }
    inline void SequenceItem::set_has_action_sequence()
    {
      _impl_._oneof_case_[0] = kActionSequence;
    }
    inline void SequenceItem::clear_action_sequence()
    {
      if (sequence_case() == kActionSequence)
      {
        if (GetArenaForAllocation() == nullptr)
        {
          delete _impl_.sequence_.action_sequence_;
        }
        clear_has_sequence();
      }
    }
    inline ::mission::v1::ActionInstruction *SequenceItem::release_action_sequence()
    {
      // @@protoc_insertion_point(field_release:mission.v1.SequenceItem.action_sequence)
      if (sequence_case() == kActionSequence)
      {
        clear_has_sequence();
        ::mission::v1::ActionInstruction *temp = _impl_.sequence_.action_sequence_;
        if (GetArenaForAllocation() != nullptr)
        {
          temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
        }
        _impl_.sequence_.action_sequence_ = nullptr;
        return temp;
      }
      else
      {
        return nullptr;
      }
    }
    inline const ::mission::v1::ActionInstruction &SequenceItem::_internal_action_sequence() const
    {
      return sequence_case() == kActionSequence
                 ? *_impl_.sequence_.action_sequence_
                 : reinterpret_cast<::mission::v1::ActionInstruction &>(::mission::v1::_ActionInstruction_default_instance_);
    }
    inline const ::mission::v1::ActionInstruction &SequenceItem::action_sequence() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SequenceItem.action_sequence)
      return _internal_action_sequence();
    }
    inline ::mission::v1::ActionInstruction *SequenceItem::unsafe_arena_release_action_sequence()
    {
      // @@protoc_insertion_point(field_unsafe_arena_release:mission.v1.SequenceItem.action_sequence)
      if (sequence_case() == kActionSequence)
      {
        clear_has_sequence();
        ::mission::v1::ActionInstruction *temp = _impl_.sequence_.action_sequence_;
        _impl_.sequence_.action_sequence_ = nullptr;
        return temp;
      }
      else
      {
        return nullptr;
      }
    }
    inline void SequenceItem::unsafe_arena_set_allocated_action_sequence(::mission::v1::ActionInstruction *action_sequence)
    {
      clear_sequence();
      if (action_sequence)
      {
        set_has_action_sequence();
        _impl_.sequence_.action_sequence_ = action_sequence;
      }
      // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mission.v1.SequenceItem.action_sequence)
    }
    inline ::mission::v1::ActionInstruction *SequenceItem::_internal_mutable_action_sequence()
    {
      if (sequence_case() != kActionSequence)
      {
        clear_sequence();
        set_has_action_sequence();
        _impl_.sequence_.action_sequence_ = CreateMaybeMessage<::mission::v1::ActionInstruction>(GetArenaForAllocation());
      }
      return _impl_.sequence_.action_sequence_;
    }
    inline ::mission::v1::ActionInstruction *SequenceItem::mutable_action_sequence()
    {
      ::mission::v1::ActionInstruction *_msg = _internal_mutable_action_sequence();
      // @@protoc_insertion_point(field_mutable:mission.v1.SequenceItem.action_sequence)
      return _msg;
    }

    // .mission.v1.TravelInstruction travel_sequence = 3;
    inline bool SequenceItem::has_travel_sequence() const
    {
      return sequence_case() == kTravelSequence;
    }
    inline bool SequenceItem::_internal_has_travel_sequence() const
    {
      return sequence_case() == kTravelSequence;
    }
    inline void SequenceItem::set_has_travel_sequence()
    {
      _impl_._oneof_case_[0] = kTravelSequence;
    }
    inline void SequenceItem::clear_travel_sequence()
    {
      if (sequence_case() == kTravelSequence)
      {
        if (GetArenaForAllocation() == nullptr)
        {
          delete _impl_.sequence_.travel_sequence_;
        }
        clear_has_sequence();
      }
    }
    inline ::mission::v1::TravelInstruction *SequenceItem::release_travel_sequence()
    {
      // @@protoc_insertion_point(field_release:mission.v1.SequenceItem.travel_sequence)
      if (sequence_case() == kTravelSequence)
      {
        clear_has_sequence();
        ::mission::v1::TravelInstruction *temp = _impl_.sequence_.travel_sequence_;
        if (GetArenaForAllocation() != nullptr)
        {
          temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
        }
        _impl_.sequence_.travel_sequence_ = nullptr;
        return temp;
      }
      else
      {
        return nullptr;
      }
    }
    inline const ::mission::v1::TravelInstruction &SequenceItem::_internal_travel_sequence() const
    {
      return sequence_case() == kTravelSequence
                 ? *_impl_.sequence_.travel_sequence_
                 : reinterpret_cast<::mission::v1::TravelInstruction &>(::mission::v1::_TravelInstruction_default_instance_);
    }
    inline const ::mission::v1::TravelInstruction &SequenceItem::travel_sequence() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SequenceItem.travel_sequence)
      return _internal_travel_sequence();
    }
    inline ::mission::v1::TravelInstruction *SequenceItem::unsafe_arena_release_travel_sequence()
    {
      // @@protoc_insertion_point(field_unsafe_arena_release:mission.v1.SequenceItem.travel_sequence)
      if (sequence_case() == kTravelSequence)
      {
        clear_has_sequence();
        ::mission::v1::TravelInstruction *temp = _impl_.sequence_.travel_sequence_;
        _impl_.sequence_.travel_sequence_ = nullptr;
        return temp;
      }
      else
      {
        return nullptr;
      }
    }
    inline void SequenceItem::unsafe_arena_set_allocated_travel_sequence(::mission::v1::TravelInstruction *travel_sequence)
    {
      clear_sequence();
      if (travel_sequence)
      {
        set_has_travel_sequence();
        _impl_.sequence_.travel_sequence_ = travel_sequence;
      }
      // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mission.v1.SequenceItem.travel_sequence)
    }
    inline ::mission::v1::TravelInstruction *SequenceItem::_internal_mutable_travel_sequence()
    {
      if (sequence_case() != kTravelSequence)
      {
        clear_sequence();
        set_has_travel_sequence();
        _impl_.sequence_.travel_sequence_ = CreateMaybeMessage<::mission::v1::TravelInstruction>(GetArenaForAllocation());
      }
      return _impl_.sequence_.travel_sequence_;
    }
    inline ::mission::v1::TravelInstruction *SequenceItem::mutable_travel_sequence()
    {
      ::mission::v1::TravelInstruction *_msg = _internal_mutable_travel_sequence();
      // @@protoc_insertion_point(field_mutable:mission.v1.SequenceItem.travel_sequence)
      return _msg;
    }

    inline bool SequenceItem::has_sequence() const
    {
      return sequence_case() != SEQUENCE_NOT_SET;
    }
    inline void SequenceItem::clear_has_sequence()
    {
      _impl_._oneof_case_[0] = SEQUENCE_NOT_SET;
    }
    inline SequenceItem::SequenceCase SequenceItem::sequence_case() const
    {
      return SequenceItem::SequenceCase(_impl_._oneof_case_[0]);
    }
    // -------------------------------------------------------------------

    // SendMissionRequest

    // string id = 1;
    inline void SendMissionRequest::clear_id()
    {
      _impl_.id_.ClearToEmpty();
    }
    inline const std::string &SendMissionRequest::id() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SendMissionRequest.id)
      return _internal_id();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void SendMissionRequest::set_id(Arg_ &&arg,
                                                                  Args_... args)
    {
      ;
      _impl_.id_.Set(static_cast<Arg_ &&>(arg), args..., GetArenaForAllocation());
      // @@protoc_insertion_point(field_set:mission.v1.SendMissionRequest.id)
    }
    inline std::string *SendMissionRequest::mutable_id()
    {
      std::string *_s = _internal_mutable_id();
      // @@protoc_insertion_point(field_mutable:mission.v1.SendMissionRequest.id)
      return _s;
    }
    inline const std::string &SendMissionRequest::_internal_id() const
    {
      return _impl_.id_.Get();
    }
    inline void SendMissionRequest::_internal_set_id(const std::string &value)
    {
      ;
      _impl_.id_.Set(value, GetArenaForAllocation());
    }
    inline std::string *SendMissionRequest::_internal_mutable_id()
    {
      ;
      return _impl_.id_.Mutable(GetArenaForAllocation());
    }
    inline std::string *SendMissionRequest::release_id()
    {
      // @@protoc_insertion_point(field_release:mission.v1.SendMissionRequest.id)
      return _impl_.id_.Release();
    }
    inline void SendMissionRequest::set_allocated_id(std::string *value)
    {
      _impl_.id_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      if (_impl_.id_.IsDefault())
      {
        _impl_.id_.Set("", GetArenaForAllocation());
      }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
      // @@protoc_insertion_point(field_set_allocated:mission.v1.SendMissionRequest.id)
    }

    // repeated .mission.v1.SequenceItem sequence_items = 2;
    inline int SendMissionRequest::_internal_sequence_items_size() const
    {
      return _impl_.sequence_items_.size();
    }
    inline int SendMissionRequest::sequence_items_size() const
    {
      return _internal_sequence_items_size();
    }
    inline void SendMissionRequest::clear_sequence_items()
    {
      _internal_mutable_sequence_items()->Clear();
    }
    inline ::mission::v1::SequenceItem *SendMissionRequest::mutable_sequence_items(int index)
    {
      // @@protoc_insertion_point(field_mutable:mission.v1.SendMissionRequest.sequence_items)
      return _internal_mutable_sequence_items()->Mutable(index);
    }
    inline ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> *
    SendMissionRequest::mutable_sequence_items()
    {
      // @@protoc_insertion_point(field_mutable_list:mission.v1.SendMissionRequest.sequence_items)
      return _internal_mutable_sequence_items();
    }
    inline const ::mission::v1::SequenceItem &SendMissionRequest::sequence_items(int index) const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SendMissionRequest.sequence_items)
      return _internal_sequence_items().Get(index);
    }
    inline ::mission::v1::SequenceItem *SendMissionRequest::add_sequence_items()
    {
      ::mission::v1::SequenceItem *_add = _internal_mutable_sequence_items()->Add();
      // @@protoc_insertion_point(field_add:mission.v1.SendMissionRequest.sequence_items)
      return _add;
    }
    inline const ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> &
    SendMissionRequest::sequence_items() const
    {
      // @@protoc_insertion_point(field_list:mission.v1.SendMissionRequest.sequence_items)
      return _internal_sequence_items();
    }
    inline const ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> &
    SendMissionRequest::_internal_sequence_items() const
    {
      return _impl_.sequence_items_;
    }
    inline ::google::protobuf::RepeatedPtrField<::mission::v1::SequenceItem> *
    SendMissionRequest::_internal_mutable_sequence_items()
    {
      return &_impl_.sequence_items_;
    }

    // -------------------------------------------------------------------

    // SingleInstruction

    // .mission.v1.SequenceItem sequence_item = 1;
    inline bool SingleInstruction::has_sequence_item() const
    {
      bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
      PROTOBUF_ASSUME(!value || _impl_.sequence_item_ != nullptr);
      return value;
    }
    inline void SingleInstruction::clear_sequence_item()
    {
      if (_impl_.sequence_item_ != nullptr)
        _impl_.sequence_item_->Clear();
      _impl_._has_bits_[0] &= ~0x00000001u;
    }
    inline const ::mission::v1::SequenceItem &SingleInstruction::_internal_sequence_item() const
    {
      const ::mission::v1::SequenceItem *p = _impl_.sequence_item_;
      return p != nullptr ? *p : reinterpret_cast<const ::mission::v1::SequenceItem &>(::mission::v1::_SequenceItem_default_instance_);
    }
    inline const ::mission::v1::SequenceItem &SingleInstruction::sequence_item() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SingleInstruction.sequence_item)
      return _internal_sequence_item();
    }
    inline void SingleInstruction::unsafe_arena_set_allocated_sequence_item(::mission::v1::SequenceItem *value)
    {
      if (GetArenaForAllocation() == nullptr)
      {
        delete reinterpret_cast<::google::protobuf::MessageLite *>(_impl_.sequence_item_);
      }
      _impl_.sequence_item_ = reinterpret_cast<::mission::v1::SequenceItem *>(value);
      if (value != nullptr)
      {
        _impl_._has_bits_[0] |= 0x00000001u;
      }
      else
      {
        _impl_._has_bits_[0] &= ~0x00000001u;
      }
      // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mission.v1.SingleInstruction.sequence_item)
    }
    inline ::mission::v1::SequenceItem *SingleInstruction::release_sequence_item()
    {

      _impl_._has_bits_[0] &= ~0x00000001u;
      ::mission::v1::SequenceItem *released = _impl_.sequence_item_;
      _impl_.sequence_item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
      auto *old = reinterpret_cast<::google::protobuf::MessageLite *>(released);
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
      if (GetArenaForAllocation() == nullptr)
      {
        delete old;
      }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
      if (GetArenaForAllocation() != nullptr)
      {
        released = ::google::protobuf::internal::DuplicateIfNonNull(released);
      }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
      return released;
    }
    inline ::mission::v1::SequenceItem *SingleInstruction::unsafe_arena_release_sequence_item()
    {
      // @@protoc_insertion_point(field_release:mission.v1.SingleInstruction.sequence_item)

      _impl_._has_bits_[0] &= ~0x00000001u;
      ::mission::v1::SequenceItem *temp = _impl_.sequence_item_;
      _impl_.sequence_item_ = nullptr;
      return temp;
    }
    inline ::mission::v1::SequenceItem *SingleInstruction::_internal_mutable_sequence_item()
    {
      _impl_._has_bits_[0] |= 0x00000001u;
      if (_impl_.sequence_item_ == nullptr)
      {
        auto *p = CreateMaybeMessage<::mission::v1::SequenceItem>(GetArenaForAllocation());
        _impl_.sequence_item_ = reinterpret_cast<::mission::v1::SequenceItem *>(p);
      }
      return _impl_.sequence_item_;
    }
    inline ::mission::v1::SequenceItem *SingleInstruction::mutable_sequence_item()
    {
      ::mission::v1::SequenceItem *_msg = _internal_mutable_sequence_item();
      // @@protoc_insertion_point(field_mutable:mission.v1.SingleInstruction.sequence_item)
      return _msg;
    }
    inline void SingleInstruction::set_allocated_sequence_item(::mission::v1::SequenceItem *value)
    {
      ::google::protobuf::Arena *message_arena = GetArenaForAllocation();
      if (message_arena == nullptr)
      {
        delete reinterpret_cast<::mission::v1::SequenceItem *>(_impl_.sequence_item_);
      }

      if (value != nullptr)
      {
        ::google::protobuf::Arena *submessage_arena =
            ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::mission::v1::SequenceItem *>(value));
        if (message_arena != submessage_arena)
        {
          value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
      }
      else
      {
        _impl_._has_bits_[0] &= ~0x00000001u;
      }

      _impl_.sequence_item_ = reinterpret_cast<::mission::v1::SequenceItem *>(value);
      // @@protoc_insertion_point(field_set_allocated:mission.v1.SingleInstruction.sequence_item)
    }

    // -------------------------------------------------------------------

    // SendMissionResult

    // bool success = 1;
    inline void SendMissionResult::clear_success()
    {
      _impl_.success_ = false;
    }
    inline bool SendMissionResult::success() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SendMissionResult.success)
      return _internal_success();
    }
    inline void SendMissionResult::set_success(bool value)
    {
      _internal_set_success(value);
      // @@protoc_insertion_point(field_set:mission.v1.SendMissionResult.success)
    }
    inline bool SendMissionResult::_internal_success() const
    {
      return _impl_.success_;
    }
    inline void SendMissionResult::_internal_set_success(bool value)
    {
      ;
      _impl_.success_ = value;
    }

    // string message = 2;
    inline void SendMissionResult::clear_message()
    {
      _impl_.message_.ClearToEmpty();
    }
    inline const std::string &SendMissionResult::message() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SendMissionResult.message)
      return _internal_message();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void SendMissionResult::set_message(Arg_ &&arg,
                                                                      Args_... args)
    {
      ;
      _impl_.message_.Set(static_cast<Arg_ &&>(arg), args..., GetArenaForAllocation());
      // @@protoc_insertion_point(field_set:mission.v1.SendMissionResult.message)
    }
    inline std::string *SendMissionResult::mutable_message()
    {
      std::string *_s = _internal_mutable_message();
      // @@protoc_insertion_point(field_mutable:mission.v1.SendMissionResult.message)
      return _s;
    }
    inline const std::string &SendMissionResult::_internal_message() const
    {
      return _impl_.message_.Get();
    }
    inline void SendMissionResult::_internal_set_message(const std::string &value)
    {
      ;
      _impl_.message_.Set(value, GetArenaForAllocation());
    }
    inline std::string *SendMissionResult::_internal_mutable_message()
    {
      ;
      return _impl_.message_.Mutable(GetArenaForAllocation());
    }
    inline std::string *SendMissionResult::release_message()
    {
      // @@protoc_insertion_point(field_release:mission.v1.SendMissionResult.message)
      return _impl_.message_.Release();
    }
    inline void SendMissionResult::set_allocated_message(std::string *value)
    {
      _impl_.message_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      if (_impl_.message_.IsDefault())
      {
        _impl_.message_.Set("", GetArenaForAllocation());
      }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
      // @@protoc_insertion_point(field_set_allocated:mission.v1.SendMissionResult.message)
    }

    // string error_message = 3;
    inline void SendMissionResult::clear_error_message()
    {
      _impl_.error_message_.ClearToEmpty();
    }
    inline const std::string &SendMissionResult::error_message() const
    {
      // @@protoc_insertion_point(field_get:mission.v1.SendMissionResult.error_message)
      return _internal_error_message();
    }
    template <typename Arg_, typename... Args_>
    inline PROTOBUF_ALWAYS_INLINE void SendMissionResult::set_error_message(Arg_ &&arg,
                                                                            Args_... args)
    {
      ;
      _impl_.error_message_.Set(static_cast<Arg_ &&>(arg), args..., GetArenaForAllocation());
      // @@protoc_insertion_point(field_set:mission.v1.SendMissionResult.error_message)
    }
    inline std::string *SendMissionResult::mutable_error_message()
    {
      std::string *_s = _internal_mutable_error_message();
      // @@protoc_insertion_point(field_mutable:mission.v1.SendMissionResult.error_message)
      return _s;
    }
    inline const std::string &SendMissionResult::_internal_error_message() const
    {
      return _impl_.error_message_.Get();
    }
    inline void SendMissionResult::_internal_set_error_message(const std::string &value)
    {
      ;
      _impl_.error_message_.Set(value, GetArenaForAllocation());
    }
    inline std::string *SendMissionResult::_internal_mutable_error_message()
    {
      ;
      return _impl_.error_message_.Mutable(GetArenaForAllocation());
    }
    inline std::string *SendMissionResult::release_error_message()
    {
      // @@protoc_insertion_point(field_release:mission.v1.SendMissionResult.error_message)
      return _impl_.error_message_.Release();
    }
    inline void SendMissionResult::set_allocated_error_message(std::string *value)
    {
      _impl_.error_message_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      if (_impl_.error_message_.IsDefault())
      {
        _impl_.error_message_.Set("", GetArenaForAllocation());
      }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
      // @@protoc_insertion_point(field_set_allocated:mission.v1.SendMissionResult.error_message)
    }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__

    // @@protoc_insertion_point(namespace_scope)
  } // namespace v1
} // namespace mission

namespace google
{
  namespace protobuf
  {

    template <>
    struct is_proto_enum<::mission::v1::Termination> : std::true_type
    {
    };
    template <>
    inline const EnumDescriptor *GetEnumDescriptor<::mission::v1::Termination>()
    {
      return ::mission::v1::Termination_descriptor();
    }
    template <>
    struct is_proto_enum<::mission::v1::Action> : std::true_type
    {
    };
    template <>
    inline const EnumDescriptor *GetEnumDescriptor<::mission::v1::Action>()
    {
      return ::mission::v1::Action_descriptor();
    }
    template <>
    struct is_proto_enum<::mission::v1::Planner> : std::true_type
    {
    };
    template <>
    inline const EnumDescriptor *GetEnumDescriptor<::mission::v1::Planner>()
    {
      return ::mission::v1::Planner_descriptor();
    }
    template <>
    struct is_proto_enum<::mission::v1::Controller> : std::true_type
    {
    };
    template <>
    inline const EnumDescriptor *GetEnumDescriptor<::mission::v1::Controller>()
    {
      return ::mission::v1::Controller_descriptor();
    }

  } // namespace protobuf
} // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif // GOOGLE_PROTOBUF_INCLUDED_mission_2eproto_2epb_2eh
