// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mission.proto

#include "mission.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace mission
{
  namespace v1
  {
    PROTOBUF_CONSTEXPR InitInstruction::InitInstruction(
        ::_pbi::ConstantInitialized) : _impl_{
                                           /*decltype(_impl_.peripheral_)*/ {}, /* _impl_._peripheral_cached_byte_size_ = */ {0}

                                           ,
                                           /*decltype(_impl_.controller_)*/ 0

                                           ,
                                           /*decltype(_impl_.terminate_)*/ 0

                                           ,
                                           /*decltype(_impl_._cached_size_)*/ {}}
    {
    }
    struct InitInstructionDefaultTypeInternal
    {
      PROTOBUF_CONSTEXPR InitInstructionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
      ~InitInstructionDefaultTypeInternal() {}
      union
      {
        InitInstruction _instance;
      };
    };

    PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
        PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitInstructionDefaultTypeInternal _InitInstruction_default_instance_;
    PROTOBUF_CONSTEXPR TravelInstruction::TravelInstruction(
        ::_pbi::ConstantInitialized) : _impl_{
                                           /*decltype(_impl_.waypoint_)*/ {}

                                           ,
                                           /*decltype(_impl_.constraint_)*/ {}

                                           ,
                                           /*decltype(_impl_.planner_)*/ 0

                                           ,
                                           /*decltype(_impl_.terminate_)*/ 0

                                           ,
                                           /*decltype(_impl_._cached_size_)*/ {}}
    {
    }
    struct TravelInstructionDefaultTypeInternal
    {
      PROTOBUF_CONSTEXPR TravelInstructionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
      ~TravelInstructionDefaultTypeInternal() {}
      union
      {
        TravelInstruction _instance;
      };
    };

    PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
        PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TravelInstructionDefaultTypeInternal _TravelInstruction_default_instance_;
    PROTOBUF_CONSTEXPR ActionInstruction::ActionInstruction(
        ::_pbi::ConstantInitialized) : _impl_{
                                           /*decltype(_impl_.package_)*/ {}, /* _impl_._package_cached_byte_size_ = */ {0}

                                           ,
                                           /*decltype(_impl_.param_)*/ 0

                                           ,
                                           /*decltype(_impl_.action_)*/ 0

                                           ,
                                           /*decltype(_impl_._cached_size_)*/ {}}
    {
    }
    struct ActionInstructionDefaultTypeInternal
    {
      PROTOBUF_CONSTEXPR ActionInstructionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
      ~ActionInstructionDefaultTypeInternal() {}
      union
      {
        ActionInstruction _instance;
      };
    };

    PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
        PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionInstructionDefaultTypeInternal _ActionInstruction_default_instance_;
    PROTOBUF_CONSTEXPR SequenceItem::SequenceItem(
        ::_pbi::ConstantInitialized) : _impl_{
                                           /*decltype(_impl_.sequence_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {}} {}
    struct SequenceItemDefaultTypeInternal
    {
      PROTOBUF_CONSTEXPR SequenceItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
      ~SequenceItemDefaultTypeInternal() {}
      union
      {
        SequenceItem _instance;
      };
    };

    PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
        PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SequenceItemDefaultTypeInternal _SequenceItem_default_instance_;
    PROTOBUF_CONSTEXPR SendMissionRequest::SendMissionRequest(
        ::_pbi::ConstantInitialized) : _impl_{
                                           /*decltype(_impl_.sequence_items_)*/ {}, /*decltype(_impl_.id_)*/ {&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}

                                           ,
                                           /*decltype(_impl_._cached_size_)*/ {}}
    {
    }
    struct SendMissionRequestDefaultTypeInternal
    {
      PROTOBUF_CONSTEXPR SendMissionRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
      ~SendMissionRequestDefaultTypeInternal() {}
      union
      {
        SendMissionRequest _instance;
      };
    };

    PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
        PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendMissionRequestDefaultTypeInternal _SendMissionRequest_default_instance_;
    PROTOBUF_CONSTEXPR SingleInstruction::SingleInstruction(
        ::_pbi::ConstantInitialized) : _impl_{
                                           /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.sequence_item_)*/ nullptr} {}
    struct SingleInstructionDefaultTypeInternal
    {
      PROTOBUF_CONSTEXPR SingleInstructionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
      ~SingleInstructionDefaultTypeInternal() {}
      union
      {
        SingleInstruction _instance;
      };
    };

    PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
        PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SingleInstructionDefaultTypeInternal _SingleInstruction_default_instance_;
    PROTOBUF_CONSTEXPR SendMissionResult::SendMissionResult(
        ::_pbi::ConstantInitialized) : _impl_{
                                           /*decltype(_impl_.message_)*/ {
                                               &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}

                                           ,
                                           /*decltype(_impl_.error_message_)*/ {
                                               &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}

                                           ,
                                           /*decltype(_impl_.success_)*/ false

                                           ,
                                           /*decltype(_impl_._cached_size_)*/ {}}
    {
    }
    struct SendMissionResultDefaultTypeInternal
    {
      PROTOBUF_CONSTEXPR SendMissionResultDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
      ~SendMissionResultDefaultTypeInternal() {}
      union
      {
        SendMissionResult _instance;
      };
    };

    PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
        PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendMissionResultDefaultTypeInternal _SendMissionResult_default_instance_;
  } // namespace v1
} // namespace mission
static ::_pb::Metadata file_level_metadata_mission_2eproto[7];
static const ::_pb::EnumDescriptor *file_level_enum_descriptors_mission_2eproto[4];
static constexpr const ::_pb::ServiceDescriptor **
    file_level_service_descriptors_mission_2eproto = nullptr;
const ::uint32_t TableStruct_mission_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u, // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mission::v1::InitInstruction, _internal_metadata_),
    ~0u, // no _extensions_
    ~0u, // no _oneof_case_
    ~0u, // no _weak_field_map_
    ~0u, // no _inlined_string_donated_
    ~0u, // no _split_
    ~0u, // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mission::v1::InitInstruction, _impl_.peripheral_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::InitInstruction, _impl_.controller_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::InitInstruction, _impl_.terminate_),
    ~0u, // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mission::v1::TravelInstruction, _internal_metadata_),
    ~0u, // no _extensions_
    ~0u, // no _oneof_case_
    ~0u, // no _weak_field_map_
    ~0u, // no _inlined_string_donated_
    ~0u, // no _split_
    ~0u, // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mission::v1::TravelInstruction, _impl_.planner_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::TravelInstruction, _impl_.waypoint_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::TravelInstruction, _impl_.constraint_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::TravelInstruction, _impl_.terminate_),
    ~0u, // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mission::v1::ActionInstruction, _internal_metadata_),
    ~0u, // no _extensions_
    ~0u, // no _oneof_case_
    ~0u, // no _weak_field_map_
    ~0u, // no _inlined_string_donated_
    ~0u, // no _split_
    ~0u, // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mission::v1::ActionInstruction, _impl_.action_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::ActionInstruction, _impl_.package_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::ActionInstruction, _impl_.param_),
    ~0u, // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mission::v1::SequenceItem, _internal_metadata_),
    ~0u, // no _extensions_
    PROTOBUF_FIELD_OFFSET(::mission::v1::SequenceItem, _impl_._oneof_case_[0]),
    ~0u, // no _weak_field_map_
    ~0u, // no _inlined_string_donated_
    ~0u, // no _split_
    ~0u, // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::mission::v1::SequenceItem, _impl_.sequence_),
    ~0u, // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mission::v1::SendMissionRequest, _internal_metadata_),
    ~0u, // no _extensions_
    ~0u, // no _oneof_case_
    ~0u, // no _weak_field_map_
    ~0u, // no _inlined_string_donated_
    ~0u, // no _split_
    ~0u, // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mission::v1::SendMissionRequest, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::SendMissionRequest, _impl_.sequence_items_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::SingleInstruction, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::SingleInstruction, _internal_metadata_),
    ~0u, // no _extensions_
    ~0u, // no _oneof_case_
    ~0u, // no _weak_field_map_
    ~0u, // no _inlined_string_donated_
    ~0u, // no _split_
    ~0u, // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mission::v1::SingleInstruction, _impl_.sequence_item_),
    0,
    ~0u, // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mission::v1::SendMissionResult, _internal_metadata_),
    ~0u, // no _extensions_
    ~0u, // no _oneof_case_
    ~0u, // no _weak_field_map_
    ~0u, // no _inlined_string_donated_
    ~0u, // no _split_
    ~0u, // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mission::v1::SendMissionResult, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::SendMissionResult, _impl_.message_),
    PROTOBUF_FIELD_OFFSET(::mission::v1::SendMissionResult, _impl_.error_message_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, -1, sizeof(::mission::v1::InitInstruction)},
        {11, -1, -1, sizeof(::mission::v1::TravelInstruction)},
        {23, -1, -1, sizeof(::mission::v1::ActionInstruction)},
        {34, -1, -1, sizeof(::mission::v1::SequenceItem)},
        {46, -1, -1, sizeof(::mission::v1::SendMissionRequest)},
        {56, 65, -1, sizeof(::mission::v1::SingleInstruction)},
        {66, -1, -1, sizeof(::mission::v1::SendMissionResult)},
};

static const ::_pb::Message *const file_default_instances[] = {
    &::mission::v1::_InitInstruction_default_instance_._instance,
    &::mission::v1::_TravelInstruction_default_instance_._instance,
    &::mission::v1::_ActionInstruction_default_instance_._instance,
    &::mission::v1::_SequenceItem_default_instance_._instance,
    &::mission::v1::_SendMissionRequest_default_instance_._instance,
    &::mission::v1::_SingleInstruction_default_instance_._instance,
    &::mission::v1::_SendMissionResult_default_instance_._instance,
};
const char descriptor_table_protodef_mission_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\rmission.proto\022\nmission.v1\"}\n\017InitInstr"
    "uction\022\022\n\nperipheral\030\001 \003(\005\022*\n\ncontroller"
    "\030\002 \001(\0162\026.mission.v1.Controller\022*\n\ttermin"
    "ate\030\003 \001(\0162\027.mission.v1.Termination\"\213\001\n\021T"
    "ravelInstruction\022$\n\007planner\030\001 \001(\0162\023.miss"
    "ion.v1.Planner\022\020\n\010waypoint\030\002 \003(\001\022\022\n\ncons"
    "traint\030\003 \003(\001\022*\n\tterminate\030\004 \001(\0162\027.missio"
    "n.v1.Termination\"W\n\021ActionInstruction\022\"\n"
    "\006action\030\001 \001(\0162\022.mission.v1.Action\022\017\n\007pac"
    "kage\030\002 \003(\005\022\r\n\005param\030\003 \001(\001\"\304\001\n\014SequenceIt"
    "em\0224\n\rinit_sequence\030\001 \001(\0132\033.mission.v1.I"
    "nitInstructionH\000\0228\n\017action_sequence\030\002 \001("
    "\0132\035.mission.v1.ActionInstructionH\000\0228\n\017tr"
    "avel_sequence\030\003 \001(\0132\035.mission.v1.TravelI"
    "nstructionH\000B\n\n\010sequence\"R\n\022SendMissionR"
    "equest\022\n\n\002id\030\001 \001(\t\0220\n\016sequence_items\030\002 \003"
    "(\0132\030.mission.v1.SequenceItem\"D\n\021SingleIn"
    "struction\022/\n\rsequence_item\030\001 \001(\0132\030.missi"
    "on.v1.SequenceItem\"L\n\021SendMissionResult\022"
    "\017\n\007success\030\001 \001(\010\022\017\n\007message\030\002 \001(\t\022\025\n\rerr"
    "or_message\030\003 \001(\t*8\n\013Termination\022\024\n\020TERMI"
    "NATION_AUTO\020\000\022\023\n\017TERMINATION_STD\020\001*\223\001\n\006A"
    "ction\022\022\n\016ACTION_TAKEOFF\020\000\022\021\n\rACTION_DISA"
    "RM\020\001\022\024\n\020ACTION_SELFCHECK\020\002\022\022\n\016ACTION_REL"
    "EASE\020\003\022\022\n\016ACTION_RTLHOME\020\004\022\017\n\013ACTION_HOL"
    "D\020\005\022\023\n\017ACTION_AUTOLAND\020\006*V\n\007Planner\022\017\n\013P"
    "LANNER_EGO\020\000\022\020\n\014PLANNER_FAST\020\001\022\022\n\016PLANNE"
    "R_MARKER\020\003\022\024\n\020PLANNER_SAFELAND\020\004*i\n\nCont"
    "roller\022\032\n\026CONTROLLER_PX4_VELO_FB\020\000\022\023\n\017CO"
    "NTROLLER_A_FB\020\001\022\023\n\017CONTROLLER_A_FW\020\002\022\025\n\021"
    "CONTROLLER_A_ADRJ\020\0032`\n\016MissionService\022N\n"
    "\013SendMission\022\036.mission.v1.SendMissionReq"
    "uest\032\035.mission.v1.SendMissionResult\"\000B2Z"
    "0github.com/saltmurai/drone-api-service/"
    "missionv1b\006proto3"};
static ::absl::once_flag descriptor_table_mission_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_mission_2eproto = {
    false,
    false,
    1377,
    descriptor_table_protodef_mission_2eproto,
    "mission.proto",
    &descriptor_table_mission_2eproto_once,
    nullptr,
    0,
    7,
    schemas,
    file_default_instances,
    TableStruct_mission_2eproto::offsets,
    file_level_metadata_mission_2eproto,
    file_level_enum_descriptors_mission_2eproto,
    file_level_service_descriptors_mission_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable *descriptor_table_mission_2eproto_getter()
{
  return &descriptor_table_mission_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_mission_2eproto(&descriptor_table_mission_2eproto);
namespace mission
{
  namespace v1
  {
    const ::google::protobuf::EnumDescriptor *Termination_descriptor()
    {
      ::google::protobuf::internal::AssignDescriptors(&descriptor_table_mission_2eproto);
      return file_level_enum_descriptors_mission_2eproto[0];
    }
    bool Termination_IsValid(int value)
    {
      switch (value)
      {
      case 0:
      case 1:
        return true;
      default:
        return false;
      }
    }
    const ::google::protobuf::EnumDescriptor *Action_descriptor()
    {
      ::google::protobuf::internal::AssignDescriptors(&descriptor_table_mission_2eproto);
      return file_level_enum_descriptors_mission_2eproto[1];
    }
    bool Action_IsValid(int value)
    {
      switch (value)
      {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
        return true;
      default:
        return false;
      }
    }
    const ::google::protobuf::EnumDescriptor *Planner_descriptor()
    {
      ::google::protobuf::internal::AssignDescriptors(&descriptor_table_mission_2eproto);
      return file_level_enum_descriptors_mission_2eproto[2];
    }
    bool Planner_IsValid(int value)
    {
      switch (value)
      {
      case 0:
      case 1:
      case 3:
      case 4:
        return true;
      default:
        return false;
      }
    }
    const ::google::protobuf::EnumDescriptor *Controller_descriptor()
    {
      ::google::protobuf::internal::AssignDescriptors(&descriptor_table_mission_2eproto);
      return file_level_enum_descriptors_mission_2eproto[3];
    }
    bool Controller_IsValid(int value)
    {
      switch (value)
      {
      case 0:
      case 1:
      case 2:
      case 3:
        return true;
      default:
        return false;
      }
    }
    // ===================================================================

    class InitInstruction::_Internal
    {
    public:
    };

    InitInstruction::InitInstruction(::google::protobuf::Arena *arena)
        : ::google::protobuf::Message(arena)
    {
      SharedCtor(arena);
      // @@protoc_insertion_point(arena_constructor:mission.v1.InitInstruction)
    }
    InitInstruction::InitInstruction(const InitInstruction &from)
        : ::google::protobuf::Message()
    {
      InitInstruction *const _this = this;
      (void)_this;
      new (&_impl_) Impl_{
          decltype(_impl_.peripheral_){from._impl_.peripheral_}, /* _impl_._peripheral_cached_byte_size_ = */ {0}

          ,
          decltype(_impl_.controller_){}

          ,
          decltype(_impl_.terminate_){}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};

      _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
      ::memcpy(&_impl_.controller_, &from._impl_.controller_,
               static_cast<::size_t>(reinterpret_cast<char *>(&_impl_.terminate_) -
                                     reinterpret_cast<char *>(&_impl_.controller_)) +
                   sizeof(_impl_.terminate_));
      // @@protoc_insertion_point(copy_constructor:mission.v1.InitInstruction)
    }

    inline void InitInstruction::SharedCtor(::_pb::Arena *arena)
    {
      (void)arena;
      new (&_impl_) Impl_{
          decltype(_impl_.peripheral_){arena}, /* _impl_._peripheral_cached_byte_size_ = */ {0}

          ,
          decltype(_impl_.controller_){0}

          ,
          decltype(_impl_.terminate_){0}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};
    }

    InitInstruction::~InitInstruction()
    {
      // @@protoc_insertion_point(destructor:mission.v1.InitInstruction)
      if (auto *arena = _internal_metadata_.DeleteReturnArena<::google::protobuf::UnknownFieldSet>())
      {
        (void)arena;
        return;
      }
      SharedDtor();
    }

    inline void InitInstruction::SharedDtor()
    {
      ABSL_DCHECK(GetArenaForAllocation() == nullptr);
      _impl_.peripheral_.~RepeatedField();
    }

    void InitInstruction::SetCachedSize(int size) const
    {
      _impl_._cached_size_.Set(size);
    }

    PROTOBUF_NOINLINE void InitInstruction::Clear()
    {
      // @@protoc_insertion_point(message_clear_start:mission.v1.InitInstruction)
      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      _internal_mutable_peripheral()->Clear();
      ::memset(&_impl_.controller_, 0, static_cast<::size_t>(reinterpret_cast<char *>(&_impl_.terminate_) - reinterpret_cast<char *>(&_impl_.controller_)) + sizeof(_impl_.terminate_));
      _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
    }

    const char *InitInstruction::_InternalParse(const char *ptr, ::_pbi::ParseContext *ctx)
    {
#define CHK_(x)                     \
  if (PROTOBUF_PREDICT_FALSE(!(x))) \
  goto failure
      while (!ctx->Done(&ptr))
      {
        ::uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3)
        {
        // repeated int32 peripheral = 1;
        case 1:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10))
          {
            ptr = ::google::protobuf::internal::PackedInt32Parser(_internal_mutable_peripheral(), ptr, ctx);
            CHK_(ptr);
          }
          else if (static_cast<::uint8_t>(tag) == 8)
          {
            _internal_mutable_peripheral()->Add(::google::protobuf::internal::ReadVarint32(&ptr));
            CHK_(ptr);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // .mission.v1.Controller controller = 2;
        case 2:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16))
          {
            ::int32_t val = ::google::protobuf::internal::ReadVarint32(&ptr);
            CHK_(ptr);
            _internal_set_controller(static_cast<::mission::v1::Controller>(val));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // .mission.v1.Termination terminate = 3;
        case 3:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24))
          {
            ::int32_t val = ::google::protobuf::internal::ReadVarint32(&ptr);
            CHK_(ptr);
            _internal_set_terminate(static_cast<::mission::v1::Termination>(val));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        default:
          goto handle_unusual;
        } // switch
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4))
        {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto message_done;
        }
        ptr = UnknownFieldParse(
            tag,
            _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
      } // while
    message_done:
      return ptr;
    failure:
      ptr = nullptr;
      goto message_done;
#undef CHK_
    }

    ::uint8_t *InitInstruction::_InternalSerialize(
        ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const
    {
      // @@protoc_insertion_point(serialize_to_array_start:mission.v1.InitInstruction)
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      // repeated int32 peripheral = 1;
      {
        int byte_size = _impl_._peripheral_cached_byte_size_.Get();
        if (byte_size > 0)
        {
          target = stream->WriteInt32Packed(1, _internal_peripheral(),
                                            byte_size, target);
        }
      }

      // .mission.v1.Controller controller = 2;
      if (this->_internal_controller() != 0)
      {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(
            2, this->_internal_controller(), target);
      }

      // .mission.v1.Termination terminate = 3;
      if (this->_internal_terminate() != 0)
      {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(
            3, this->_internal_terminate(), target);
      }

      if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields()))
      {
        target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
      }
      // @@protoc_insertion_point(serialize_to_array_end:mission.v1.InitInstruction)
      return target;
    }

    ::size_t InitInstruction::ByteSizeLong() const
    {
      // @@protoc_insertion_point(message_byte_size_start:mission.v1.InitInstruction)
      ::size_t total_size = 0;

      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      // repeated int32 peripheral = 1;
      {
        std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
            this->_internal_peripheral());
        _impl_._peripheral_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
        std::size_t tag_size = data_size == 0
                                   ? 0
                                   : 1 + ::_pbi::WireFormatLite::Int32Size(
                                             static_cast<int32_t>(data_size));
        total_size += tag_size + data_size;
      }

      // .mission.v1.Controller controller = 2;
      if (this->_internal_controller() != 0)
      {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this->_internal_controller());
      }

      // .mission.v1.Termination terminate = 3;
      if (this->_internal_terminate() != 0)
      {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this->_internal_terminate());
      }

      return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
    }

    const ::google::protobuf::Message::ClassData InitInstruction::_class_data_ = {
        ::google::protobuf::Message::CopyWithSourceCheck,
        InitInstruction::MergeImpl};
    const ::google::protobuf::Message::ClassData *InitInstruction::GetClassData() const { return &_class_data_; }

    void InitInstruction::MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg)
    {
      auto *const _this = static_cast<InitInstruction *>(&to_msg);
      auto &from = static_cast<const InitInstruction &>(from_msg);
      // @@protoc_insertion_point(class_specific_merge_from_start:mission.v1.InitInstruction)
      ABSL_DCHECK_NE(&from, _this);
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      _this->_impl_.peripheral_.MergeFrom(from._impl_.peripheral_);
      if (from._internal_controller() != 0)
      {
        _this->_internal_set_controller(from._internal_controller());
      }
      if (from._internal_terminate() != 0)
      {
        _this->_internal_set_terminate(from._internal_terminate());
      }
      _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
    }

    void InitInstruction::CopyFrom(const InitInstruction &from)
    {
      // @@protoc_insertion_point(class_specific_copy_from_start:mission.v1.InitInstruction)
      if (&from == this)
        return;
      Clear();
      MergeFrom(from);
    }

    PROTOBUF_NOINLINE bool InitInstruction::IsInitialized() const
    {
      return true;
    }

    void InitInstruction::InternalSwap(InitInstruction *other)
    {
      using std::swap;
      _internal_metadata_.InternalSwap(&other->_internal_metadata_);
      _impl_.peripheral_.InternalSwap(&other->_impl_.peripheral_);
      ::google::protobuf::internal::memswap<
          PROTOBUF_FIELD_OFFSET(InitInstruction, _impl_.terminate_) + sizeof(InitInstruction::_impl_.terminate_) - PROTOBUF_FIELD_OFFSET(InitInstruction, _impl_.controller_)>(
          reinterpret_cast<char *>(&_impl_.controller_),
          reinterpret_cast<char *>(&other->_impl_.controller_));
    }

    ::google::protobuf::Metadata InitInstruction::GetMetadata() const
    {
      return ::_pbi::AssignDescriptors(
          &descriptor_table_mission_2eproto_getter, &descriptor_table_mission_2eproto_once,
          file_level_metadata_mission_2eproto[0]);
    }
    // ===================================================================

    class TravelInstruction::_Internal
    {
    public:
    };

    TravelInstruction::TravelInstruction(::google::protobuf::Arena *arena)
        : ::google::protobuf::Message(arena)
    {
      SharedCtor(arena);
      // @@protoc_insertion_point(arena_constructor:mission.v1.TravelInstruction)
    }
    TravelInstruction::TravelInstruction(const TravelInstruction &from)
        : ::google::protobuf::Message()
    {
      TravelInstruction *const _this = this;
      (void)_this;
      new (&_impl_) Impl_{
          decltype(_impl_.waypoint_){from._impl_.waypoint_}

          ,
          decltype(_impl_.constraint_){from._impl_.constraint_}

          ,
          decltype(_impl_.planner_){}

          ,
          decltype(_impl_.terminate_){}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};

      _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
      ::memcpy(&_impl_.planner_, &from._impl_.planner_,
               static_cast<::size_t>(reinterpret_cast<char *>(&_impl_.terminate_) -
                                     reinterpret_cast<char *>(&_impl_.planner_)) +
                   sizeof(_impl_.terminate_));
      // @@protoc_insertion_point(copy_constructor:mission.v1.TravelInstruction)
    }

    inline void TravelInstruction::SharedCtor(::_pb::Arena *arena)
    {
      (void)arena;
      new (&_impl_) Impl_{
          decltype(_impl_.waypoint_){arena}

          ,
          decltype(_impl_.constraint_){arena}

          ,
          decltype(_impl_.planner_){0}

          ,
          decltype(_impl_.terminate_){0}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};
    }

    TravelInstruction::~TravelInstruction()
    {
      // @@protoc_insertion_point(destructor:mission.v1.TravelInstruction)
      if (auto *arena = _internal_metadata_.DeleteReturnArena<::google::protobuf::UnknownFieldSet>())
      {
        (void)arena;
        return;
      }
      SharedDtor();
    }

    inline void TravelInstruction::SharedDtor()
    {
      ABSL_DCHECK(GetArenaForAllocation() == nullptr);
      _impl_.waypoint_.~RepeatedField();
      _impl_.constraint_.~RepeatedField();
    }

    void TravelInstruction::SetCachedSize(int size) const
    {
      _impl_._cached_size_.Set(size);
    }

    PROTOBUF_NOINLINE void TravelInstruction::Clear()
    {
      // @@protoc_insertion_point(message_clear_start:mission.v1.TravelInstruction)
      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      _internal_mutable_waypoint()->Clear();
      _internal_mutable_constraint()->Clear();
      ::memset(&_impl_.planner_, 0, static_cast<::size_t>(reinterpret_cast<char *>(&_impl_.terminate_) - reinterpret_cast<char *>(&_impl_.planner_)) + sizeof(_impl_.terminate_));
      _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
    }

    const char *TravelInstruction::_InternalParse(const char *ptr, ::_pbi::ParseContext *ctx)
    {
#define CHK_(x)                     \
  if (PROTOBUF_PREDICT_FALSE(!(x))) \
  goto failure
      while (!ctx->Done(&ptr))
      {
        ::uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3)
        {
        // .mission.v1.Planner planner = 1;
        case 1:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8))
          {
            ::int32_t val = ::google::protobuf::internal::ReadVarint32(&ptr);
            CHK_(ptr);
            _internal_set_planner(static_cast<::mission::v1::Planner>(val));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // repeated double waypoint = 2;
        case 2:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18))
          {
            ptr = ::google::protobuf::internal::PackedDoubleParser(_internal_mutable_waypoint(), ptr, ctx);
            CHK_(ptr);
          }
          else if (static_cast<::uint8_t>(tag) == 17)
          {
            _internal_mutable_waypoint()->Add(::google::protobuf::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // repeated double constraint = 3;
        case 3:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26))
          {
            ptr = ::google::protobuf::internal::PackedDoubleParser(_internal_mutable_constraint(), ptr, ctx);
            CHK_(ptr);
          }
          else if (static_cast<::uint8_t>(tag) == 25)
          {
            _internal_mutable_constraint()->Add(::google::protobuf::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // .mission.v1.Termination terminate = 4;
        case 4:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32))
          {
            ::int32_t val = ::google::protobuf::internal::ReadVarint32(&ptr);
            CHK_(ptr);
            _internal_set_terminate(static_cast<::mission::v1::Termination>(val));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        default:
          goto handle_unusual;
        } // switch
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4))
        {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto message_done;
        }
        ptr = UnknownFieldParse(
            tag,
            _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
      } // while
    message_done:
      return ptr;
    failure:
      ptr = nullptr;
      goto message_done;
#undef CHK_
    }

    ::uint8_t *TravelInstruction::_InternalSerialize(
        ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const
    {
      // @@protoc_insertion_point(serialize_to_array_start:mission.v1.TravelInstruction)
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      // .mission.v1.Planner planner = 1;
      if (this->_internal_planner() != 0)
      {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(
            1, this->_internal_planner(), target);
      }

      // repeated double waypoint = 2;
      if (this->_internal_waypoint_size() > 0)
      {
        target = stream->WriteFixedPacked(2, _internal_waypoint(), target);
      }

      // repeated double constraint = 3;
      if (this->_internal_constraint_size() > 0)
      {
        target = stream->WriteFixedPacked(3, _internal_constraint(), target);
      }

      // .mission.v1.Termination terminate = 4;
      if (this->_internal_terminate() != 0)
      {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(
            4, this->_internal_terminate(), target);
      }

      if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields()))
      {
        target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
      }
      // @@protoc_insertion_point(serialize_to_array_end:mission.v1.TravelInstruction)
      return target;
    }

    ::size_t TravelInstruction::ByteSizeLong() const
    {
      // @@protoc_insertion_point(message_byte_size_start:mission.v1.TravelInstruction)
      ::size_t total_size = 0;

      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      // repeated double waypoint = 2;
      {
        std::size_t data_size = std::size_t{8} *
                                ::_pbi::FromIntSize(this->_internal_waypoint_size());
        std::size_t tag_size = data_size == 0
                                   ? 0
                                   : 1 + ::_pbi::WireFormatLite::Int32Size(
                                             static_cast<int32_t>(data_size));
        total_size += tag_size + data_size;
      }

      // repeated double constraint = 3;
      {
        std::size_t data_size = std::size_t{8} *
                                ::_pbi::FromIntSize(this->_internal_constraint_size());
        std::size_t tag_size = data_size == 0
                                   ? 0
                                   : 1 + ::_pbi::WireFormatLite::Int32Size(
                                             static_cast<int32_t>(data_size));
        total_size += tag_size + data_size;
      }

      // .mission.v1.Planner planner = 1;
      if (this->_internal_planner() != 0)
      {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this->_internal_planner());
      }

      // .mission.v1.Termination terminate = 4;
      if (this->_internal_terminate() != 0)
      {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this->_internal_terminate());
      }

      return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
    }

    const ::google::protobuf::Message::ClassData TravelInstruction::_class_data_ = {
        ::google::protobuf::Message::CopyWithSourceCheck,
        TravelInstruction::MergeImpl};
    const ::google::protobuf::Message::ClassData *TravelInstruction::GetClassData() const { return &_class_data_; }

    void TravelInstruction::MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg)
    {
      auto *const _this = static_cast<TravelInstruction *>(&to_msg);
      auto &from = static_cast<const TravelInstruction &>(from_msg);
      // @@protoc_insertion_point(class_specific_merge_from_start:mission.v1.TravelInstruction)
      ABSL_DCHECK_NE(&from, _this);
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      _this->_impl_.waypoint_.MergeFrom(from._impl_.waypoint_);
      _this->_impl_.constraint_.MergeFrom(from._impl_.constraint_);
      if (from._internal_planner() != 0)
      {
        _this->_internal_set_planner(from._internal_planner());
      }
      if (from._internal_terminate() != 0)
      {
        _this->_internal_set_terminate(from._internal_terminate());
      }
      _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
    }

    void TravelInstruction::CopyFrom(const TravelInstruction &from)
    {
      // @@protoc_insertion_point(class_specific_copy_from_start:mission.v1.TravelInstruction)
      if (&from == this)
        return;
      Clear();
      MergeFrom(from);
    }

    PROTOBUF_NOINLINE bool TravelInstruction::IsInitialized() const
    {
      return true;
    }

    void TravelInstruction::InternalSwap(TravelInstruction *other)
    {
      using std::swap;
      _internal_metadata_.InternalSwap(&other->_internal_metadata_);
      _impl_.waypoint_.InternalSwap(&other->_impl_.waypoint_);
      _impl_.constraint_.InternalSwap(&other->_impl_.constraint_);
      ::google::protobuf::internal::memswap<
          PROTOBUF_FIELD_OFFSET(TravelInstruction, _impl_.terminate_) + sizeof(TravelInstruction::_impl_.terminate_) - PROTOBUF_FIELD_OFFSET(TravelInstruction, _impl_.planner_)>(
          reinterpret_cast<char *>(&_impl_.planner_),
          reinterpret_cast<char *>(&other->_impl_.planner_));
    }

    ::google::protobuf::Metadata TravelInstruction::GetMetadata() const
    {
      return ::_pbi::AssignDescriptors(
          &descriptor_table_mission_2eproto_getter, &descriptor_table_mission_2eproto_once,
          file_level_metadata_mission_2eproto[1]);
    }
    // ===================================================================

    class ActionInstruction::_Internal
    {
    public:
    };

    ActionInstruction::ActionInstruction(::google::protobuf::Arena *arena)
        : ::google::protobuf::Message(arena)
    {
      SharedCtor(arena);
      // @@protoc_insertion_point(arena_constructor:mission.v1.ActionInstruction)
    }
    ActionInstruction::ActionInstruction(const ActionInstruction &from)
        : ::google::protobuf::Message()
    {
      ActionInstruction *const _this = this;
      (void)_this;
      new (&_impl_) Impl_{
          decltype(_impl_.package_){from._impl_.package_}, /* _impl_._package_cached_byte_size_ = */ {0}

          ,
          decltype(_impl_.param_){}

          ,
          decltype(_impl_.action_){}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};

      _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
      ::memcpy(&_impl_.param_, &from._impl_.param_,
               static_cast<::size_t>(reinterpret_cast<char *>(&_impl_.action_) -
                                     reinterpret_cast<char *>(&_impl_.param_)) +
                   sizeof(_impl_.action_));
      // @@protoc_insertion_point(copy_constructor:mission.v1.ActionInstruction)
    }

    inline void ActionInstruction::SharedCtor(::_pb::Arena *arena)
    {
      (void)arena;
      new (&_impl_) Impl_{
          decltype(_impl_.package_){arena}, /* _impl_._package_cached_byte_size_ = */ {0}

          ,
          decltype(_impl_.param_){0}

          ,
          decltype(_impl_.action_){0}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};
    }

    ActionInstruction::~ActionInstruction()
    {
      // @@protoc_insertion_point(destructor:mission.v1.ActionInstruction)
      if (auto *arena = _internal_metadata_.DeleteReturnArena<::google::protobuf::UnknownFieldSet>())
      {
        (void)arena;
        return;
      }
      SharedDtor();
    }

    inline void ActionInstruction::SharedDtor()
    {
      ABSL_DCHECK(GetArenaForAllocation() == nullptr);
      _impl_.package_.~RepeatedField();
    }

    void ActionInstruction::SetCachedSize(int size) const
    {
      _impl_._cached_size_.Set(size);
    }

    PROTOBUF_NOINLINE void ActionInstruction::Clear()
    {
      // @@protoc_insertion_point(message_clear_start:mission.v1.ActionInstruction)
      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      _internal_mutable_package()->Clear();
      ::memset(&_impl_.param_, 0, static_cast<::size_t>(reinterpret_cast<char *>(&_impl_.action_) - reinterpret_cast<char *>(&_impl_.param_)) + sizeof(_impl_.action_));
      _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
    }

    const char *ActionInstruction::_InternalParse(const char *ptr, ::_pbi::ParseContext *ctx)
    {
#define CHK_(x)                     \
  if (PROTOBUF_PREDICT_FALSE(!(x))) \
  goto failure
      while (!ctx->Done(&ptr))
      {
        ::uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3)
        {
        // .mission.v1.Action action = 1;
        case 1:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8))
          {
            ::int32_t val = ::google::protobuf::internal::ReadVarint32(&ptr);
            CHK_(ptr);
            _internal_set_action(static_cast<::mission::v1::Action>(val));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // repeated int32 package = 2;
        case 2:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18))
          {
            ptr = ::google::protobuf::internal::PackedInt32Parser(_internal_mutable_package(), ptr, ctx);
            CHK_(ptr);
          }
          else if (static_cast<::uint8_t>(tag) == 16)
          {
            _internal_mutable_package()->Add(::google::protobuf::internal::ReadVarint32(&ptr));
            CHK_(ptr);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // double param = 3;
        case 3:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25))
          {
            _impl_.param_ = ::google::protobuf::internal::UnalignedLoad<double>(ptr);
            ptr += sizeof(double);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        default:
          goto handle_unusual;
        } // switch
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4))
        {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto message_done;
        }
        ptr = UnknownFieldParse(
            tag,
            _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
      } // while
    message_done:
      return ptr;
    failure:
      ptr = nullptr;
      goto message_done;
#undef CHK_
    }

    ::uint8_t *ActionInstruction::_InternalSerialize(
        ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const
    {
      // @@protoc_insertion_point(serialize_to_array_start:mission.v1.ActionInstruction)
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      // .mission.v1.Action action = 1;
      if (this->_internal_action() != 0)
      {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(
            1, this->_internal_action(), target);
      }

      // repeated int32 package = 2;
      {
        int byte_size = _impl_._package_cached_byte_size_.Get();
        if (byte_size > 0)
        {
          target = stream->WriteInt32Packed(2, _internal_package(),
                                            byte_size, target);
        }
      }

      // double param = 3;
      static_assert(sizeof(::uint64_t) == sizeof(double),
                    "Code assumes ::uint64_t and double are the same size.");
      double tmp_param = this->_internal_param();
      ::uint64_t raw_param;
      memcpy(&raw_param, &tmp_param, sizeof(tmp_param));
      if (raw_param != 0)
      {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(
            3, this->_internal_param(), target);
      }

      if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields()))
      {
        target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
      }
      // @@protoc_insertion_point(serialize_to_array_end:mission.v1.ActionInstruction)
      return target;
    }

    ::size_t ActionInstruction::ByteSizeLong() const
    {
      // @@protoc_insertion_point(message_byte_size_start:mission.v1.ActionInstruction)
      ::size_t total_size = 0;

      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      // repeated int32 package = 2;
      {
        std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
            this->_internal_package());
        _impl_._package_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
        std::size_t tag_size = data_size == 0
                                   ? 0
                                   : 1 + ::_pbi::WireFormatLite::Int32Size(
                                             static_cast<int32_t>(data_size));
        total_size += tag_size + data_size;
      }

      // double param = 3;
      static_assert(sizeof(::uint64_t) == sizeof(double),
                    "Code assumes ::uint64_t and double are the same size.");
      double tmp_param = this->_internal_param();
      ::uint64_t raw_param;
      memcpy(&raw_param, &tmp_param, sizeof(tmp_param));
      if (raw_param != 0)
      {
        total_size += 9;
      }

      // .mission.v1.Action action = 1;
      if (this->_internal_action() != 0)
      {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
      }

      return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
    }

    const ::google::protobuf::Message::ClassData ActionInstruction::_class_data_ = {
        ::google::protobuf::Message::CopyWithSourceCheck,
        ActionInstruction::MergeImpl};
    const ::google::protobuf::Message::ClassData *ActionInstruction::GetClassData() const { return &_class_data_; }

    void ActionInstruction::MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg)
    {
      auto *const _this = static_cast<ActionInstruction *>(&to_msg);
      auto &from = static_cast<const ActionInstruction &>(from_msg);
      // @@protoc_insertion_point(class_specific_merge_from_start:mission.v1.ActionInstruction)
      ABSL_DCHECK_NE(&from, _this);
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      _this->_impl_.package_.MergeFrom(from._impl_.package_);
      static_assert(sizeof(::uint64_t) == sizeof(double),
                    "Code assumes ::uint64_t and double are the same size.");
      double tmp_param = from._internal_param();
      ::uint64_t raw_param;
      memcpy(&raw_param, &tmp_param, sizeof(tmp_param));
      if (raw_param != 0)
      {
        _this->_internal_set_param(from._internal_param());
      }
      if (from._internal_action() != 0)
      {
        _this->_internal_set_action(from._internal_action());
      }
      _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
    }

    void ActionInstruction::CopyFrom(const ActionInstruction &from)
    {
      // @@protoc_insertion_point(class_specific_copy_from_start:mission.v1.ActionInstruction)
      if (&from == this)
        return;
      Clear();
      MergeFrom(from);
    }

    PROTOBUF_NOINLINE bool ActionInstruction::IsInitialized() const
    {
      return true;
    }

    void ActionInstruction::InternalSwap(ActionInstruction *other)
    {
      using std::swap;
      _internal_metadata_.InternalSwap(&other->_internal_metadata_);
      _impl_.package_.InternalSwap(&other->_impl_.package_);
      ::google::protobuf::internal::memswap<
          PROTOBUF_FIELD_OFFSET(ActionInstruction, _impl_.action_) + sizeof(ActionInstruction::_impl_.action_) - PROTOBUF_FIELD_OFFSET(ActionInstruction, _impl_.param_)>(
          reinterpret_cast<char *>(&_impl_.param_),
          reinterpret_cast<char *>(&other->_impl_.param_));
    }

    ::google::protobuf::Metadata ActionInstruction::GetMetadata() const
    {
      return ::_pbi::AssignDescriptors(
          &descriptor_table_mission_2eproto_getter, &descriptor_table_mission_2eproto_once,
          file_level_metadata_mission_2eproto[2]);
    }
    // ===================================================================

    class SequenceItem::_Internal
    {
    public:
      static constexpr ::int32_t kOneofCaseOffset =
          PROTOBUF_FIELD_OFFSET(::mission::v1::SequenceItem, _impl_._oneof_case_);
      static const ::mission::v1::InitInstruction &init_sequence(const SequenceItem *msg);
      static const ::mission::v1::ActionInstruction &action_sequence(const SequenceItem *msg);
      static const ::mission::v1::TravelInstruction &travel_sequence(const SequenceItem *msg);
    };

    const ::mission::v1::InitInstruction &SequenceItem::_Internal::init_sequence(const SequenceItem *msg)
    {
      return *msg->_impl_.sequence_.init_sequence_;
    }
    const ::mission::v1::ActionInstruction &SequenceItem::_Internal::action_sequence(const SequenceItem *msg)
    {
      return *msg->_impl_.sequence_.action_sequence_;
    }
    const ::mission::v1::TravelInstruction &SequenceItem::_Internal::travel_sequence(const SequenceItem *msg)
    {
      return *msg->_impl_.sequence_.travel_sequence_;
    }
    void SequenceItem::set_allocated_init_sequence(::mission::v1::InitInstruction *init_sequence)
    {
      ::google::protobuf::Arena *message_arena = GetArenaForAllocation();
      clear_sequence();
      if (init_sequence)
      {
        ::google::protobuf::Arena *submessage_arena =
            ::google::protobuf::Arena::InternalGetOwningArena(init_sequence);
        if (message_arena != submessage_arena)
        {
          init_sequence = ::google::protobuf::internal::GetOwnedMessage(
              message_arena, init_sequence, submessage_arena);
        }
        set_has_init_sequence();
        _impl_.sequence_.init_sequence_ = init_sequence;
      }
      // @@protoc_insertion_point(field_set_allocated:mission.v1.SequenceItem.init_sequence)
    }
    void SequenceItem::set_allocated_action_sequence(::mission::v1::ActionInstruction *action_sequence)
    {
      ::google::protobuf::Arena *message_arena = GetArenaForAllocation();
      clear_sequence();
      if (action_sequence)
      {
        ::google::protobuf::Arena *submessage_arena =
            ::google::protobuf::Arena::InternalGetOwningArena(action_sequence);
        if (message_arena != submessage_arena)
        {
          action_sequence = ::google::protobuf::internal::GetOwnedMessage(
              message_arena, action_sequence, submessage_arena);
        }
        set_has_action_sequence();
        _impl_.sequence_.action_sequence_ = action_sequence;
      }
      // @@protoc_insertion_point(field_set_allocated:mission.v1.SequenceItem.action_sequence)
    }
    void SequenceItem::set_allocated_travel_sequence(::mission::v1::TravelInstruction *travel_sequence)
    {
      ::google::protobuf::Arena *message_arena = GetArenaForAllocation();
      clear_sequence();
      if (travel_sequence)
      {
        ::google::protobuf::Arena *submessage_arena =
            ::google::protobuf::Arena::InternalGetOwningArena(travel_sequence);
        if (message_arena != submessage_arena)
        {
          travel_sequence = ::google::protobuf::internal::GetOwnedMessage(
              message_arena, travel_sequence, submessage_arena);
        }
        set_has_travel_sequence();
        _impl_.sequence_.travel_sequence_ = travel_sequence;
      }
      // @@protoc_insertion_point(field_set_allocated:mission.v1.SequenceItem.travel_sequence)
    }
    SequenceItem::SequenceItem(::google::protobuf::Arena *arena)
        : ::google::protobuf::Message(arena)
    {
      SharedCtor(arena);
      // @@protoc_insertion_point(arena_constructor:mission.v1.SequenceItem)
    }
    SequenceItem::SequenceItem(const SequenceItem &from)
        : ::google::protobuf::Message()
    {
      SequenceItem *const _this = this;
      (void)_this;
      new (&_impl_) Impl_{
          decltype(_impl_.sequence_){}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {}};

      _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
      clear_has_sequence();
      switch (from.sequence_case())
      {
      case kInitSequence:
      {
        _this->_internal_mutable_init_sequence()->::mission::v1::InitInstruction::MergeFrom(
            from._internal_init_sequence());
        break;
      }
      case kActionSequence:
      {
        _this->_internal_mutable_action_sequence()->::mission::v1::ActionInstruction::MergeFrom(
            from._internal_action_sequence());
        break;
      }
      case kTravelSequence:
      {
        _this->_internal_mutable_travel_sequence()->::mission::v1::TravelInstruction::MergeFrom(
            from._internal_travel_sequence());
        break;
      }
      case SEQUENCE_NOT_SET:
      {
        break;
      }
      }
      // @@protoc_insertion_point(copy_constructor:mission.v1.SequenceItem)
    }

    inline void SequenceItem::SharedCtor(::_pb::Arena *arena)
    {
      (void)arena;
      new (&_impl_) Impl_{
          decltype(_impl_.sequence_){}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {}};
      clear_has_sequence();
    }

    SequenceItem::~SequenceItem()
    {
      // @@protoc_insertion_point(destructor:mission.v1.SequenceItem)
      if (auto *arena = _internal_metadata_.DeleteReturnArena<::google::protobuf::UnknownFieldSet>())
      {
        (void)arena;
        return;
      }
      SharedDtor();
    }

    inline void SequenceItem::SharedDtor()
    {
      ABSL_DCHECK(GetArenaForAllocation() == nullptr);
      if (has_sequence())
      {
        clear_sequence();
      }
    }

    void SequenceItem::SetCachedSize(int size) const
    {
      _impl_._cached_size_.Set(size);
    }

    void SequenceItem::clear_sequence()
    {
      // @@protoc_insertion_point(one_of_clear_start:mission.v1.SequenceItem)
      switch (sequence_case())
      {
      case kInitSequence:
      {
        if (GetArenaForAllocation() == nullptr)
        {
          delete _impl_.sequence_.init_sequence_;
        }
        break;
      }
      case kActionSequence:
      {
        if (GetArenaForAllocation() == nullptr)
        {
          delete _impl_.sequence_.action_sequence_;
        }
        break;
      }
      case kTravelSequence:
      {
        if (GetArenaForAllocation() == nullptr)
        {
          delete _impl_.sequence_.travel_sequence_;
        }
        break;
      }
      case SEQUENCE_NOT_SET:
      {
        break;
      }
      }
      _impl_._oneof_case_[0] = SEQUENCE_NOT_SET;
    }

    PROTOBUF_NOINLINE void SequenceItem::Clear()
    {
      // @@protoc_insertion_point(message_clear_start:mission.v1.SequenceItem)
      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      clear_sequence();
      _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
    }

    const char *SequenceItem::_InternalParse(const char *ptr, ::_pbi::ParseContext *ctx)
    {
#define CHK_(x)                     \
  if (PROTOBUF_PREDICT_FALSE(!(x))) \
  goto failure
      while (!ctx->Done(&ptr))
      {
        ::uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3)
        {
        // .mission.v1.InitInstruction init_sequence = 1;
        case 1:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10))
          {
            ptr = ctx->ParseMessage(_internal_mutable_init_sequence(), ptr);
            CHK_(ptr);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // .mission.v1.ActionInstruction action_sequence = 2;
        case 2:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18))
          {
            ptr = ctx->ParseMessage(_internal_mutable_action_sequence(), ptr);
            CHK_(ptr);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // .mission.v1.TravelInstruction travel_sequence = 3;
        case 3:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26))
          {
            ptr = ctx->ParseMessage(_internal_mutable_travel_sequence(), ptr);
            CHK_(ptr);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        default:
          goto handle_unusual;
        } // switch
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4))
        {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto message_done;
        }
        ptr = UnknownFieldParse(
            tag,
            _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
      } // while
    message_done:
      return ptr;
    failure:
      ptr = nullptr;
      goto message_done;
#undef CHK_
    }

    ::uint8_t *SequenceItem::_InternalSerialize(
        ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const
    {
      // @@protoc_insertion_point(serialize_to_array_start:mission.v1.SequenceItem)
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      switch (sequence_case())
      {
      case kInitSequence:
      {
        target = ::google::protobuf::internal::WireFormatLite::
            InternalWriteMessage(1, _Internal::init_sequence(this),
                                 _Internal::init_sequence(this).GetCachedSize(), target, stream);
        break;
      }
      case kActionSequence:
      {
        target = ::google::protobuf::internal::WireFormatLite::
            InternalWriteMessage(2, _Internal::action_sequence(this),
                                 _Internal::action_sequence(this).GetCachedSize(), target, stream);
        break;
      }
      case kTravelSequence:
      {
        target = ::google::protobuf::internal::WireFormatLite::
            InternalWriteMessage(3, _Internal::travel_sequence(this),
                                 _Internal::travel_sequence(this).GetCachedSize(), target, stream);
        break;
      }
      default:;
      }
      if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields()))
      {
        target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
      }
      // @@protoc_insertion_point(serialize_to_array_end:mission.v1.SequenceItem)
      return target;
    }

    ::size_t SequenceItem::ByteSizeLong() const
    {
      // @@protoc_insertion_point(message_byte_size_start:mission.v1.SequenceItem)
      ::size_t total_size = 0;

      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      switch (sequence_case())
      {
      // .mission.v1.InitInstruction init_sequence = 1;
      case kInitSequence:
      {
        total_size += 1 +
                      ::google::protobuf::internal::WireFormatLite::MessageSize(
                          *_impl_.sequence_.init_sequence_);
        break;
      }
      // .mission.v1.ActionInstruction action_sequence = 2;
      case kActionSequence:
      {
        total_size += 1 +
                      ::google::protobuf::internal::WireFormatLite::MessageSize(
                          *_impl_.sequence_.action_sequence_);
        break;
      }
      // .mission.v1.TravelInstruction travel_sequence = 3;
      case kTravelSequence:
      {
        total_size += 1 +
                      ::google::protobuf::internal::WireFormatLite::MessageSize(
                          *_impl_.sequence_.travel_sequence_);
        break;
      }
      case SEQUENCE_NOT_SET:
      {
        break;
      }
      }
      return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
    }

    const ::google::protobuf::Message::ClassData SequenceItem::_class_data_ = {
        ::google::protobuf::Message::CopyWithSourceCheck,
        SequenceItem::MergeImpl};
    const ::google::protobuf::Message::ClassData *SequenceItem::GetClassData() const { return &_class_data_; }

    void SequenceItem::MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg)
    {
      auto *const _this = static_cast<SequenceItem *>(&to_msg);
      auto &from = static_cast<const SequenceItem &>(from_msg);
      // @@protoc_insertion_point(class_specific_merge_from_start:mission.v1.SequenceItem)
      ABSL_DCHECK_NE(&from, _this);
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      switch (from.sequence_case())
      {
      case kInitSequence:
      {
        _this->_internal_mutable_init_sequence()->::mission::v1::InitInstruction::MergeFrom(
            from._internal_init_sequence());
        break;
      }
      case kActionSequence:
      {
        _this->_internal_mutable_action_sequence()->::mission::v1::ActionInstruction::MergeFrom(
            from._internal_action_sequence());
        break;
      }
      case kTravelSequence:
      {
        _this->_internal_mutable_travel_sequence()->::mission::v1::TravelInstruction::MergeFrom(
            from._internal_travel_sequence());
        break;
      }
      case SEQUENCE_NOT_SET:
      {
        break;
      }
      }
      _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
    }

    void SequenceItem::CopyFrom(const SequenceItem &from)
    {
      // @@protoc_insertion_point(class_specific_copy_from_start:mission.v1.SequenceItem)
      if (&from == this)
        return;
      Clear();
      MergeFrom(from);
    }

    PROTOBUF_NOINLINE bool SequenceItem::IsInitialized() const
    {
      return true;
    }

    void SequenceItem::InternalSwap(SequenceItem *other)
    {
      using std::swap;
      _internal_metadata_.InternalSwap(&other->_internal_metadata_);
      swap(_impl_.sequence_, other->_impl_.sequence_);
      swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
    }

    ::google::protobuf::Metadata SequenceItem::GetMetadata() const
    {
      return ::_pbi::AssignDescriptors(
          &descriptor_table_mission_2eproto_getter, &descriptor_table_mission_2eproto_once,
          file_level_metadata_mission_2eproto[3]);
    }
    // ===================================================================

    class SendMissionRequest::_Internal
    {
    public:
    };

    SendMissionRequest::SendMissionRequest(::google::protobuf::Arena *arena)
        : ::google::protobuf::Message(arena)
    {
      SharedCtor(arena);
      // @@protoc_insertion_point(arena_constructor:mission.v1.SendMissionRequest)
    }
    SendMissionRequest::SendMissionRequest(const SendMissionRequest &from)
        : ::google::protobuf::Message()
    {
      SendMissionRequest *const _this = this;
      (void)_this;
      new (&_impl_) Impl_{
          decltype(_impl_.sequence_items_){from._impl_.sequence_items_}, decltype(_impl_.id_){}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};

      _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
      _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
      if (!from._internal_id().empty())
      {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
      }
      // @@protoc_insertion_point(copy_constructor:mission.v1.SendMissionRequest)
    }

    inline void SendMissionRequest::SharedCtor(::_pb::Arena *arena)
    {
      (void)arena;
      new (&_impl_) Impl_{
          decltype(_impl_.sequence_items_){arena}, decltype(_impl_.id_){}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};
      _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    }

    SendMissionRequest::~SendMissionRequest()
    {
      // @@protoc_insertion_point(destructor:mission.v1.SendMissionRequest)
      if (auto *arena = _internal_metadata_.DeleteReturnArena<::google::protobuf::UnknownFieldSet>())
      {
        (void)arena;
        return;
      }
      SharedDtor();
    }

    inline void SendMissionRequest::SharedDtor()
    {
      ABSL_DCHECK(GetArenaForAllocation() == nullptr);
      _impl_.sequence_items_.~RepeatedPtrField();
      _impl_.id_.Destroy();
    }

    void SendMissionRequest::SetCachedSize(int size) const
    {
      _impl_._cached_size_.Set(size);
    }

    PROTOBUF_NOINLINE void SendMissionRequest::Clear()
    {
      // @@protoc_insertion_point(message_clear_start:mission.v1.SendMissionRequest)
      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      _internal_mutable_sequence_items()->Clear();
      _impl_.id_.ClearToEmpty();
      _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
    }

    const char *SendMissionRequest::_InternalParse(const char *ptr, ::_pbi::ParseContext *ctx)
    {
#define CHK_(x)                     \
  if (PROTOBUF_PREDICT_FALSE(!(x))) \
  goto failure
      while (!ctx->Done(&ptr))
      {
        ::uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3)
        {
        // string id = 1;
        case 1:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10))
          {
            auto str = _internal_mutable_id();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "mission.v1.SendMissionRequest.id"));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // repeated .mission.v1.SequenceItem sequence_items = 2;
        case 2:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18))
          {
            ptr -= 1;
            do
            {
              ptr += 1;
              ptr = ctx->ParseMessage(_internal_mutable_sequence_items()->Add(), ptr);
              CHK_(ptr);
              if (!ctx->DataAvailable(ptr))
                break;
            } while (::google::protobuf::internal::ExpectTag<18>(ptr));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        default:
          goto handle_unusual;
        } // switch
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4))
        {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto message_done;
        }
        ptr = UnknownFieldParse(
            tag,
            _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
      } // while
    message_done:
      return ptr;
    failure:
      ptr = nullptr;
      goto message_done;
#undef CHK_
    }

    ::uint8_t *SendMissionRequest::_InternalSerialize(
        ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const
    {
      // @@protoc_insertion_point(serialize_to_array_start:mission.v1.SendMissionRequest)
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      // string id = 1;
      if (!this->_internal_id().empty())
      {
        const std::string &_s = this->_internal_id();
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mission.v1.SendMissionRequest.id");
        target = stream->WriteStringMaybeAliased(1, _s, target);
      }

      // repeated .mission.v1.SequenceItem sequence_items = 2;
      for (unsigned i = 0,
                    n = static_cast<unsigned>(this->_internal_sequence_items_size());
           i < n; i++)
      {
        const auto &repfield = this->_internal_sequence_items().Get(i);
        target = ::google::protobuf::internal::WireFormatLite::
            InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
      }

      if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields()))
      {
        target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
      }
      // @@protoc_insertion_point(serialize_to_array_end:mission.v1.SendMissionRequest)
      return target;
    }

    ::size_t SendMissionRequest::ByteSizeLong() const
    {
      // @@protoc_insertion_point(message_byte_size_start:mission.v1.SendMissionRequest)
      ::size_t total_size = 0;

      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      // repeated .mission.v1.SequenceItem sequence_items = 2;
      total_size += 1UL * this->_internal_sequence_items_size();
      for (const auto &msg : this->_internal_sequence_items())
      {
        total_size +=
            ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }

      // string id = 1;
      if (!this->_internal_id().empty())
      {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->_internal_id());
      }

      return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
    }

    const ::google::protobuf::Message::ClassData SendMissionRequest::_class_data_ = {
        ::google::protobuf::Message::CopyWithSourceCheck,
        SendMissionRequest::MergeImpl};
    const ::google::protobuf::Message::ClassData *SendMissionRequest::GetClassData() const { return &_class_data_; }

    void SendMissionRequest::MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg)
    {
      auto *const _this = static_cast<SendMissionRequest *>(&to_msg);
      auto &from = static_cast<const SendMissionRequest &>(from_msg);
      // @@protoc_insertion_point(class_specific_merge_from_start:mission.v1.SendMissionRequest)
      ABSL_DCHECK_NE(&from, _this);
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      _this->_internal_mutable_sequence_items()->MergeFrom(from._internal_sequence_items());
      if (!from._internal_id().empty())
      {
        _this->_internal_set_id(from._internal_id());
      }
      _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
    }

    void SendMissionRequest::CopyFrom(const SendMissionRequest &from)
    {
      // @@protoc_insertion_point(class_specific_copy_from_start:mission.v1.SendMissionRequest)
      if (&from == this)
        return;
      Clear();
      MergeFrom(from);
    }

    PROTOBUF_NOINLINE bool SendMissionRequest::IsInitialized() const
    {
      return true;
    }

    void SendMissionRequest::InternalSwap(SendMissionRequest *other)
    {
      using std::swap;
      auto *lhs_arena = GetArenaForAllocation();
      auto *rhs_arena = other->GetArenaForAllocation();
      _internal_metadata_.InternalSwap(&other->_internal_metadata_);
      _internal_mutable_sequence_items()->InternalSwap(other->_internal_mutable_sequence_items());
      ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                           &other->_impl_.id_, rhs_arena);
    }

    ::google::protobuf::Metadata SendMissionRequest::GetMetadata() const
    {
      return ::_pbi::AssignDescriptors(
          &descriptor_table_mission_2eproto_getter, &descriptor_table_mission_2eproto_once,
          file_level_metadata_mission_2eproto[4]);
    }
    // ===================================================================

    class SingleInstruction::_Internal
    {
    public:
      using HasBits = decltype(std::declval<SingleInstruction>()._impl_._has_bits_);
      static constexpr ::int32_t kHasBitsOffset =
          8 * PROTOBUF_FIELD_OFFSET(SingleInstruction, _impl_._has_bits_);
      static const ::mission::v1::SequenceItem &sequence_item(const SingleInstruction *msg);
      static void set_has_sequence_item(HasBits *has_bits)
      {
        (*has_bits)[0] |= 1u;
      }
    };

    const ::mission::v1::SequenceItem &SingleInstruction::_Internal::sequence_item(const SingleInstruction *msg)
    {
      return *msg->_impl_.sequence_item_;
    }
    SingleInstruction::SingleInstruction(::google::protobuf::Arena *arena)
        : ::google::protobuf::Message(arena)
    {
      SharedCtor(arena);
      // @@protoc_insertion_point(arena_constructor:mission.v1.SingleInstruction)
    }
    SingleInstruction::SingleInstruction(const SingleInstruction &from)
        : ::google::protobuf::Message()
    {
      SingleInstruction *const _this = this;
      (void)_this;
      new (&_impl_) Impl_{
          decltype(_impl_._has_bits_){from._impl_._has_bits_}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sequence_item_){nullptr}};

      _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
      if ((from._impl_._has_bits_[0] & 0x00000001u) != 0)
      {
        _this->_impl_.sequence_item_ = new ::mission::v1::SequenceItem(*from._impl_.sequence_item_);
      }
      // @@protoc_insertion_point(copy_constructor:mission.v1.SingleInstruction)
    }

    inline void SingleInstruction::SharedCtor(::_pb::Arena *arena)
    {
      (void)arena;
      new (&_impl_) Impl_{
          decltype(_impl_._has_bits_){}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sequence_item_){nullptr}};
    }

    SingleInstruction::~SingleInstruction()
    {
      // @@protoc_insertion_point(destructor:mission.v1.SingleInstruction)
      if (auto *arena = _internal_metadata_.DeleteReturnArena<::google::protobuf::UnknownFieldSet>())
      {
        (void)arena;
        return;
      }
      SharedDtor();
    }

    inline void SingleInstruction::SharedDtor()
    {
      ABSL_DCHECK(GetArenaForAllocation() == nullptr);
      if (this != internal_default_instance())
        delete _impl_.sequence_item_;
    }

    void SingleInstruction::SetCachedSize(int size) const
    {
      _impl_._cached_size_.Set(size);
    }

    PROTOBUF_NOINLINE void SingleInstruction::Clear()
    {
      // @@protoc_insertion_point(message_clear_start:mission.v1.SingleInstruction)
      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      cached_has_bits = _impl_._has_bits_[0];
      if (cached_has_bits & 0x00000001u)
      {
        ABSL_DCHECK(_impl_.sequence_item_ != nullptr);
        _impl_.sequence_item_->Clear();
      }
      _impl_._has_bits_.Clear();
      _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
    }

    const char *SingleInstruction::_InternalParse(const char *ptr, ::_pbi::ParseContext *ctx)
    {
#define CHK_(x)                     \
  if (PROTOBUF_PREDICT_FALSE(!(x))) \
  goto failure
      _Internal::HasBits has_bits{};
      while (!ctx->Done(&ptr))
      {
        ::uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3)
        {
        // .mission.v1.SequenceItem sequence_item = 1;
        case 1:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10))
          {
            ptr = ctx->ParseMessage(_internal_mutable_sequence_item(), ptr);
            CHK_(ptr);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        default:
          goto handle_unusual;
        } // switch
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4))
        {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto message_done;
        }
        ptr = UnknownFieldParse(
            tag,
            _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
      } // while
    message_done:
      _impl_._has_bits_.Or(has_bits);
      return ptr;
    failure:
      ptr = nullptr;
      goto message_done;
#undef CHK_
    }

    ::uint8_t *SingleInstruction::_InternalSerialize(
        ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const
    {
      // @@protoc_insertion_point(serialize_to_array_start:mission.v1.SingleInstruction)
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      cached_has_bits = _impl_._has_bits_[0];
      // .mission.v1.SequenceItem sequence_item = 1;
      if (cached_has_bits & 0x00000001u)
      {
        target = ::google::protobuf::internal::WireFormatLite::
            InternalWriteMessage(1, _Internal::sequence_item(this),
                                 _Internal::sequence_item(this).GetCachedSize(), target, stream);
      }

      if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields()))
      {
        target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
      }
      // @@protoc_insertion_point(serialize_to_array_end:mission.v1.SingleInstruction)
      return target;
    }

    ::size_t SingleInstruction::ByteSizeLong() const
    {
      // @@protoc_insertion_point(message_byte_size_start:mission.v1.SingleInstruction)
      ::size_t total_size = 0;

      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      // .mission.v1.SequenceItem sequence_item = 1;
      cached_has_bits = _impl_._has_bits_[0];
      if (cached_has_bits & 0x00000001u)
      {
        total_size += 1 +
                      ::google::protobuf::internal::WireFormatLite::MessageSize(
                          *_impl_.sequence_item_);
      }

      return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
    }

    const ::google::protobuf::Message::ClassData SingleInstruction::_class_data_ = {
        ::google::protobuf::Message::CopyWithSourceCheck,
        SingleInstruction::MergeImpl};
    const ::google::protobuf::Message::ClassData *SingleInstruction::GetClassData() const { return &_class_data_; }

    void SingleInstruction::MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg)
    {
      auto *const _this = static_cast<SingleInstruction *>(&to_msg);
      auto &from = static_cast<const SingleInstruction &>(from_msg);
      // @@protoc_insertion_point(class_specific_merge_from_start:mission.v1.SingleInstruction)
      ABSL_DCHECK_NE(&from, _this);
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      if ((from._impl_._has_bits_[0] & 0x00000001u) != 0)
      {
        _this->_internal_mutable_sequence_item()->::mission::v1::SequenceItem::MergeFrom(
            from._internal_sequence_item());
      }
      _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
    }

    void SingleInstruction::CopyFrom(const SingleInstruction &from)
    {
      // @@protoc_insertion_point(class_specific_copy_from_start:mission.v1.SingleInstruction)
      if (&from == this)
        return;
      Clear();
      MergeFrom(from);
    }

    PROTOBUF_NOINLINE bool SingleInstruction::IsInitialized() const
    {
      return true;
    }

    void SingleInstruction::InternalSwap(SingleInstruction *other)
    {
      using std::swap;
      _internal_metadata_.InternalSwap(&other->_internal_metadata_);
      swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
      swap(_impl_.sequence_item_, other->_impl_.sequence_item_);
    }

    ::google::protobuf::Metadata SingleInstruction::GetMetadata() const
    {
      return ::_pbi::AssignDescriptors(
          &descriptor_table_mission_2eproto_getter, &descriptor_table_mission_2eproto_once,
          file_level_metadata_mission_2eproto[5]);
    }
    // ===================================================================

    class SendMissionResult::_Internal
    {
    public:
    };

    SendMissionResult::SendMissionResult(::google::protobuf::Arena *arena)
        : ::google::protobuf::Message(arena)
    {
      SharedCtor(arena);
      // @@protoc_insertion_point(arena_constructor:mission.v1.SendMissionResult)
    }
    SendMissionResult::SendMissionResult(const SendMissionResult &from)
        : ::google::protobuf::Message()
    {
      SendMissionResult *const _this = this;
      (void)_this;
      new (&_impl_) Impl_{
          decltype(_impl_.message_){}

          ,
          decltype(_impl_.error_message_){}

          ,
          decltype(_impl_.success_){}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};

      _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
      _impl_.message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      _impl_.message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
      if (!from._internal_message().empty())
      {
        _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
      }
      _impl_.error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      _impl_.error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
      if (!from._internal_error_message().empty())
      {
        _this->_impl_.error_message_.Set(from._internal_error_message(), _this->GetArenaForAllocation());
      }
      _this->_impl_.success_ = from._impl_.success_;
      // @@protoc_insertion_point(copy_constructor:mission.v1.SendMissionResult)
    }

    inline void SendMissionResult::SharedCtor(::_pb::Arena *arena)
    {
      (void)arena;
      new (&_impl_) Impl_{
          decltype(_impl_.message_){}

          ,
          decltype(_impl_.error_message_){}

          ,
          decltype(_impl_.success_){false}

          ,
          /*decltype(_impl_._cached_size_)*/ {}};
      _impl_.message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      _impl_.message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
      _impl_.error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
      _impl_.error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    }

    SendMissionResult::~SendMissionResult()
    {
      // @@protoc_insertion_point(destructor:mission.v1.SendMissionResult)
      if (auto *arena = _internal_metadata_.DeleteReturnArena<::google::protobuf::UnknownFieldSet>())
      {
        (void)arena;
        return;
      }
      SharedDtor();
    }

    inline void SendMissionResult::SharedDtor()
    {
      ABSL_DCHECK(GetArenaForAllocation() == nullptr);
      _impl_.message_.Destroy();
      _impl_.error_message_.Destroy();
    }

    void SendMissionResult::SetCachedSize(int size) const
    {
      _impl_._cached_size_.Set(size);
    }

    PROTOBUF_NOINLINE void SendMissionResult::Clear()
    {
      // @@protoc_insertion_point(message_clear_start:mission.v1.SendMissionResult)
      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      _impl_.message_.ClearToEmpty();
      _impl_.error_message_.ClearToEmpty();
      _impl_.success_ = false;
      _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
    }

    const char *SendMissionResult::_InternalParse(const char *ptr, ::_pbi::ParseContext *ctx)
    {
#define CHK_(x)                     \
  if (PROTOBUF_PREDICT_FALSE(!(x))) \
  goto failure
      while (!ctx->Done(&ptr))
      {
        ::uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3)
        {
        // bool success = 1;
        case 1:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8))
          {
            _impl_.success_ = ::google::protobuf::internal::ReadVarint64(&ptr);
            CHK_(ptr);
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // string message = 2;
        case 2:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18))
          {
            auto str = _internal_mutable_message();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "mission.v1.SendMissionResult.message"));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        // string error_message = 3;
        case 3:
          if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26))
          {
            auto str = _internal_mutable_error_message();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "mission.v1.SendMissionResult.error_message"));
          }
          else
          {
            goto handle_unusual;
          }
          continue;
        default:
          goto handle_unusual;
        } // switch
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4))
        {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto message_done;
        }
        ptr = UnknownFieldParse(
            tag,
            _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
      } // while
    message_done:
      return ptr;
    failure:
      ptr = nullptr;
      goto message_done;
#undef CHK_
    }

    ::uint8_t *SendMissionResult::_InternalSerialize(
        ::uint8_t *target, ::google::protobuf::io::EpsCopyOutputStream *stream) const
    {
      // @@protoc_insertion_point(serialize_to_array_start:mission.v1.SendMissionResult)
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      // bool success = 1;
      if (this->_internal_success() != 0)
      {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(
            1, this->_internal_success(), target);
      }

      // string message = 2;
      if (!this->_internal_message().empty())
      {
        const std::string &_s = this->_internal_message();
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mission.v1.SendMissionResult.message");
        target = stream->WriteStringMaybeAliased(2, _s, target);
      }

      // string error_message = 3;
      if (!this->_internal_error_message().empty())
      {
        const std::string &_s = this->_internal_error_message();
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mission.v1.SendMissionResult.error_message");
        target = stream->WriteStringMaybeAliased(3, _s, target);
      }

      if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields()))
      {
        target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
      }
      // @@protoc_insertion_point(serialize_to_array_end:mission.v1.SendMissionResult)
      return target;
    }

    ::size_t SendMissionResult::ByteSizeLong() const
    {
      // @@protoc_insertion_point(message_byte_size_start:mission.v1.SendMissionResult)
      ::size_t total_size = 0;

      ::uint32_t cached_has_bits = 0;
      // Prevent compiler warnings about cached_has_bits being unused
      (void)cached_has_bits;

      // string message = 2;
      if (!this->_internal_message().empty())
      {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->_internal_message());
      }

      // string error_message = 3;
      if (!this->_internal_error_message().empty())
      {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                              this->_internal_error_message());
      }

      // bool success = 1;
      if (this->_internal_success() != 0)
      {
        total_size += 2;
      }

      return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
    }

    const ::google::protobuf::Message::ClassData SendMissionResult::_class_data_ = {
        ::google::protobuf::Message::CopyWithSourceCheck,
        SendMissionResult::MergeImpl};
    const ::google::protobuf::Message::ClassData *SendMissionResult::GetClassData() const { return &_class_data_; }

    void SendMissionResult::MergeImpl(::google::protobuf::Message &to_msg, const ::google::protobuf::Message &from_msg)
    {
      auto *const _this = static_cast<SendMissionResult *>(&to_msg);
      auto &from = static_cast<const SendMissionResult &>(from_msg);
      // @@protoc_insertion_point(class_specific_merge_from_start:mission.v1.SendMissionResult)
      ABSL_DCHECK_NE(&from, _this);
      ::uint32_t cached_has_bits = 0;
      (void)cached_has_bits;

      if (!from._internal_message().empty())
      {
        _this->_internal_set_message(from._internal_message());
      }
      if (!from._internal_error_message().empty())
      {
        _this->_internal_set_error_message(from._internal_error_message());
      }
      if (from._internal_success() != 0)
      {
        _this->_internal_set_success(from._internal_success());
      }
      _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
    }

    void SendMissionResult::CopyFrom(const SendMissionResult &from)
    {
      // @@protoc_insertion_point(class_specific_copy_from_start:mission.v1.SendMissionResult)
      if (&from == this)
        return;
      Clear();
      MergeFrom(from);
    }

    PROTOBUF_NOINLINE bool SendMissionResult::IsInitialized() const
    {
      return true;
    }

    void SendMissionResult::InternalSwap(SendMissionResult *other)
    {
      using std::swap;
      auto *lhs_arena = GetArenaForAllocation();
      auto *rhs_arena = other->GetArenaForAllocation();
      _internal_metadata_.InternalSwap(&other->_internal_metadata_);
      ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                           &other->_impl_.message_, rhs_arena);
      ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_message_, lhs_arena,
                                           &other->_impl_.error_message_, rhs_arena);
      swap(_impl_.success_, other->_impl_.success_);
    }

    ::google::protobuf::Metadata SendMissionResult::GetMetadata() const
    {
      return ::_pbi::AssignDescriptors(
          &descriptor_table_mission_2eproto_getter, &descriptor_table_mission_2eproto_once,
          file_level_metadata_mission_2eproto[6]);
    }
    // @@protoc_insertion_point(namespace_scope)
  } // namespace v1
} // namespace mission
namespace google
{
  namespace protobuf
  {
    template <>
    PROTOBUF_NOINLINE ::mission::v1::InitInstruction *
    Arena::CreateMaybeMessage<::mission::v1::InitInstruction>(Arena *arena)
    {
      return Arena::CreateMessageInternal<::mission::v1::InitInstruction>(arena);
    }
    template <>
    PROTOBUF_NOINLINE ::mission::v1::TravelInstruction *
    Arena::CreateMaybeMessage<::mission::v1::TravelInstruction>(Arena *arena)
    {
      return Arena::CreateMessageInternal<::mission::v1::TravelInstruction>(arena);
    }
    template <>
    PROTOBUF_NOINLINE ::mission::v1::ActionInstruction *
    Arena::CreateMaybeMessage<::mission::v1::ActionInstruction>(Arena *arena)
    {
      return Arena::CreateMessageInternal<::mission::v1::ActionInstruction>(arena);
    }
    template <>
    PROTOBUF_NOINLINE ::mission::v1::SequenceItem *
    Arena::CreateMaybeMessage<::mission::v1::SequenceItem>(Arena *arena)
    {
      return Arena::CreateMessageInternal<::mission::v1::SequenceItem>(arena);
    }
    template <>
    PROTOBUF_NOINLINE ::mission::v1::SendMissionRequest *
    Arena::CreateMaybeMessage<::mission::v1::SendMissionRequest>(Arena *arena)
    {
      return Arena::CreateMessageInternal<::mission::v1::SendMissionRequest>(arena);
    }
    template <>
    PROTOBUF_NOINLINE ::mission::v1::SingleInstruction *
    Arena::CreateMaybeMessage<::mission::v1::SingleInstruction>(Arena *arena)
    {
      return Arena::CreateMessageInternal<::mission::v1::SingleInstruction>(arena);
    }
    template <>
    PROTOBUF_NOINLINE ::mission::v1::SendMissionResult *
    Arena::CreateMaybeMessage<::mission::v1::SendMissionResult>(Arena *arena)
    {
      return Arena::CreateMessageInternal<::mission::v1::SendMissionResult>(arena);
    }
  } // namespace protobuf
} // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
